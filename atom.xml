<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee の 博客</title>
  
  <subtitle>学习永不止步</subtitle>
  <link href="https://lf2021.github.io/atom.xml" rel="self"/>
  
  <link href="https://lf2021.github.io/"/>
  <updated>2021-03-06T16:00:00.000Z</updated>
  <id>https://lf2021.github.io/</id>
  
  <author>
    <name>Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React自定义主题配置</title>
    <link href="https://lf2021.github.io/2021/03/07/2021.3.7React%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://lf2021.github.io/2021/03/07/2021.3.7React%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</id>
    <published>2021-03-06T16:00:00.000Z</published>
    <updated>2021-03-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-自定义-antd-主题方法编译失败与解决办法"><a href="#React-自定义-antd-主题方法编译失败与解决办法" class="headerlink" title="React 自定义 antd 主题方法编译失败与解决办法"></a>React 自定义 antd 主题方法编译失败与解决办法</h2><h3 id="一、按照官网操作"><a href="#一、按照官网操作" class="headerlink" title="一、按照官网操作"></a>一、按照官网操作</h3><p>首先我是按照<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener"><strong>官网的步骤</strong></a>一步一步操作下来的：</p><ol><li><p>安装 <code>less</code> 和 <code>less-loader</code></p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader</span><br></pre></td></tr></table></figure></li><li><p>引入 <code>customize-cra</code> 中提供的 <code>less</code> 相关的函数 <code>addLessLoader</code> 来帮助加载 <code>less</code> 样式，同时修改 <code>config-overrides.js</code> 文件如下:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置具体的修改规则</span></span><br><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports,addLessLoader&#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd'</span>,</span><br><span class="line">    libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a></li></ol><h3 id="二、出现的问题"><a href="#二、出现的问题" class="headerlink" title="二、出现的问题"></a>二、出现的问题</h3><ol><li><p><code>addLessLoader</code> 这块出现以下问题</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ValidationError: <span class="title">Invalid</span> <span class="title">options</span> <span class="title">object</span>. <span class="title">Less</span> <span class="title">Loader</span> <span class="title">has</span> <span class="title">been</span> <span class="title">initialized</span> <span class="title">using</span> <span class="title">an</span> <span class="title">options</span> <span class="title">object</span></span></span><br><span class="line"><span class="function"><span class="title">that</span> <span class="title">does</span> <span class="title">not</span> <span class="title">match</span> <span class="title">the</span> <span class="title">API</span> <span class="title">schema</span>.</span></span><br><span class="line"><span class="function">- <span class="title">options</span> <span class="title">has</span> <span class="title">a</span> <span class="title">unknown</span> <span class="title">property</span> '<span class="title">modifyVars</span>'. <span class="title">These</span> <span class="title">properties</span> <span class="title">are</span> <span class="title">valid</span>: </span></span><br><span class="line"><span class="function"><span class="title">object</span> &#123; <span class="title">lessOptions</span>?, <span class="title">additonalData</span>?, <span class="title">sourceMap</span>?, <span class="title">webpackImporter</span>? &#125;</span></span><br></pre></td></tr></table></figure><p> 这是由于 <code>less</code> 更新了导致的，解决办法：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addLessLoader(&#123;</span><br><span class="line">  lessOptions:&#123;  </span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>编译出错如下</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TypeError: <span class="title">this.getOptions</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span> <span class="title">function</span></span></span><br></pre></td></tr></table></figure><p> 解决方案：我装的都是最新版本<code>less@4.1.1</code> <code>less-loader@8.0.0</code> ，我们需要降低版本，亲测以下两个版本可以。</p><ul><li><p>先卸载 <code>less</code> 和 <code>less-loader</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less less-loader</span><br></pre></td></tr></table></figure></li><li><p>再安装指定版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less@<span class="number">3</span>.<span class="number">12</span>.<span class="number">2</span> less-loader@<span class="number">7</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>前端技术更新太快的同时就会带来不兼容的问题，我们能做的就是<strong>乐在其中</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;React-自定义-antd-主题方法编译失败与解决办法&quot;&gt;&lt;a href=&quot;#React-自定义-antd-主题方法编译失败与解决办法&quot; class=&quot;headerlink&quot; title=&quot;React 自定义 antd 主题方法编译失败与解决办法&quot;&gt;&lt;/a&gt;React 自定义 antd 主题方法编译失败与解决办法&lt;/h2&gt;&lt;h3 id=&quot;一、按照官网操作&quot;&gt;&lt;a href=&quot;#一、按照官网操作&quot; class=&quot;headerlink&quot; title=&quot;一、按照官网操作&quot;&gt;&lt;/a&gt;一、按照官网操作&lt;/h3&gt;&lt;p&gt;首先我是按照&lt;a href=&quot;https://3x.ant.design/docs/react/use-with-create-react-app-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;官网的步骤&lt;/strong&gt;&lt;/a&gt;一步一步操作下来的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 &lt;code&gt;less&lt;/code&gt; 和 &lt;code&gt;less-loader&lt;/code&gt;&lt;/p&gt;
 &lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install less less-loader&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引入 &lt;code&gt;customize-cra&lt;/code&gt; 中提供的 &lt;code&gt;less&lt;/code&gt; 相关的函数 &lt;code&gt;addLessLoader&lt;/code&gt; 来帮助加载 &lt;code&gt;less&lt;/code&gt; 样式，同时修改 &lt;code&gt;config-overrides.js&lt;/code&gt; 文件如下:&lt;/p&gt;
 &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//配置具体的修改规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; override, fixBabelImports,addLessLoader&amp;#125; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;customize-cra&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = override(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fixBabelImports(&lt;span class=&quot;string&quot;&gt;&#39;import&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    libraryName: &lt;span class=&quot;string&quot;&gt;&#39;antd&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    libraryDirectory: &lt;span class=&quot;string&quot;&gt;&#39;es&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    style: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  addLessLoader(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    javascriptEnabled: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modifyVars: &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;@primary-color&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="React" scheme="https://lf2021.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://lf2021.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.2.25</title>
    <link href="https://lf2021.github.io/2021/02/25/lc2021.2.25/"/>
    <id>https://lf2021.github.io/2021/02/25/lc2021.2.25/</id>
    <published>2021-02-24T16:00:00.000Z</published>
    <updated>2021-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">867. 转置矩阵</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p><p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p><img data-src="/images/loading.gif" data-original="/images/20210225.png" alt="20210225"></p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$m = matrix.length$</li><li>$n = matrix[i].length$</li><li>$1 \le m, n \le 1000$</li><li>$1 \le m * n \le 10^{5}$</li><li>$-10^{9} ≤ matrix[i][j] ≤ 10^{9}$</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">横纵坐标对换位置即可，很简单。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m * n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。</li><li>空间复杂度：$O(1)$。除了返回值以外，额外使用的空间为常数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transpose = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>(col).fill(<span class="number">0</span>).map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">Array</span>(row).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            res[j][i] = matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;867-转置矩阵&quot;&gt;&lt;a href=&quot;#867-转置矩阵&quot; class=&quot;headerlink&quot; title=&quot;867. 转置矩阵&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/transpose-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;867. 转置矩阵&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;matrix&lt;/code&gt;， 返回 &lt;code&gt;matrix&lt;/code&gt; 的 &lt;strong&gt;转置矩阵&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;矩阵的 &lt;strong&gt;转置&lt;/strong&gt; 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/loading.gif&quot; data-original=&quot;/images/20210225.png&quot; alt=&quot;20210225&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.2.22</title>
    <link href="https://lf2021.github.io/2021/02/22/lc2021.2.22/"/>
    <id>https://lf2021.github.io/2021/02/22/lc2021.2.22/</id>
    <published>2021-02-21T16:00:00.000Z</published>
    <updated>2021-02-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p><a id="more"></a><p><strong>示例1：</strong></p><p><img data-src="/images/loading.gif" data-original="/images/2021022201.jpg" alt="示例1图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img data-src="/images/loading.gif" data-original="/images/2021022202.jpg" alt="示例2图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[2,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m = matrix.length</code></li><li><code>n = matrix[i].length</code></li><li><code>1 ≤ m, n ≤ 20</code></li><li><code>0 ≤ matrix[i][j] ≤ 99</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据定义，当且仅当矩阵中每个元素都与其左上角相邻的元素（如果存在）相等时，该矩阵为托普利茨矩阵。</span><br><span class="line"></span><br><span class="line">因此，我们遍历该矩阵，将每一个元素和它左上角的元素相比对即可。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m * n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。</li><li>空间复杂度：$O(1)$</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isToeplitzMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] !== matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;766-托普利茨矩阵&quot;&gt;&lt;a href=&quot;#766-托普利茨矩阵&quot; class=&quot;headerlink&quot; title=&quot;766. 托普利茨矩阵&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/toeplitz-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;766. 托普利茨矩阵&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给你一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵 &lt;code&gt;matrix&lt;/code&gt; 。如果这个矩阵是托普利茨矩阵，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 &lt;strong&gt;托普利茨矩阵&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.2.6</title>
    <link href="https://lf2021.github.io/2021/02/06/lc2021.2.6/"/>
    <id>https://lf2021.github.io/2021/02/06/lc2021.2.6/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。<br><a id="more"></a></p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$1 ≤ cardPoints.length ≤ 10^{5}$</li><li>$1 ≤ cardPoints[i] ≤ 10^{4}$</li><li>$1 ≤ k ≤ cardPoints.length$</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>思路如下：</p><hr><p>题目限制我们只能从开头或结尾拿数字，那么最后剩下的数字一定是连续的</p><p>这样我们可以换一种思维，我们找到连续数字和最小的这个滑动窗口即可</p><p>滑动窗口的长度:</p><script type="math/tex; mode=display">windowSize = cardPoints.length - k</script><hr><ul><li>时间复杂度：$O(n)$，其中 $n$ 是数组 $cardPoints$ 的长度。</li><li>空间复杂度：$O(1)$</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxScore = <span class="function"><span class="keyword">function</span> (<span class="params">cardPoints, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cardPoints.length;</span><br><span class="line">    <span class="comment">// 所有数字之和</span></span><br><span class="line">    <span class="keyword">let</span> total = cardPoints.reduce(<span class="function">(<span class="params">preVal, curVal</span>) =&gt;</span> preVal + curVal);</span><br><span class="line">    <span class="keyword">let</span> windowSize = n - k;</span><br><span class="line">    <span class="comment">// 算出起始滑动窗口中数字之和</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; windowSize; i++) &#123;</span><br><span class="line">        sum += cardPoints[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护一个变量 min 保存滑动窗口中数字之和的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = windowSize; j &lt; n; j++) &#123;</span><br><span class="line">        sum = sum - cardPoints[j-windowSize] + cardPoints[j];</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total - min</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1423-可获得的最大点数&quot;&gt;&lt;a href=&quot;#1423-可获得的最大点数&quot; class=&quot;headerlink&quot; title=&quot;1423. 可获得的最大点数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1423. 可获得的最大点数&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;几张卡牌 &lt;strong&gt;排成一行&lt;/strong&gt;，每张卡牌都有一个对应的点数。点数由整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 给出。&lt;/p&gt;
&lt;p&gt;每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 &lt;code&gt;k&lt;/code&gt; 张卡牌。&lt;/p&gt;
&lt;p&gt;你的点数就是你拿到手中的所有卡牌的点数之和。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请你返回可以获得的最大点数。&lt;br&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.2.1</title>
    <link href="https://lf2021.github.io/2021/02/01/lc2021.2.1/"/>
    <id>https://lf2021.github.io/2021/02/01/lc2021.2.1/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="888-公平的糖果棒交换"><a href="#888-公平的糖果棒交换" class="headerlink" title="888. 公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果棒交换</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p><p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。<br><a id="more"></a></p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2], B &#x3D; [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [2], B &#x3D; [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,5], B &#x3D; [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 ≤ A.length ≤ 10000</code></li><li><code>1 ≤ B.length ≤ 10000</code></li><li><code>1 ≤ A[i] ≤ 100000</code></li><li><code>1 ≤ B[i] ≤ 100000</code></li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>思路如下：</p><hr><p>这是一个纯数学问题，我们来把它数学化：</p><p>假设我们最后得结果是 $[a, b]$，也就是 $a$ 是 $A$ 要交换得，$b$ 是 $B$ 要交换的</p><p>我们可以计算分别得到 $A$ 和 $B$ 的和为 $aSum$ 和 $bSum$，那我们会有如下关系：</p><script type="math/tex; mode=display">aSum - a + b = bSum - b + a</script><p>转化一下可以得到：</p><script type="math/tex; mode=display">a = b + \frac{aSum - bSum}{2}</script><p>其实问题就是：对于 $B$ 中的任一数 $b$，在 $A$ 中存在一个数 $a$，满足上述关系式。</p><hr><ul><li>时间复杂度：$O(n+m)$，$n$ 和 $m$ 分别为 $A$ 和 $B$ 的长度。</li><li>空间复杂度：$O(n)$。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fairCandySwap = <span class="function"><span class="keyword">function</span> (<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aSum = A.reduce(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> preValue + curValue);</span><br><span class="line">    <span class="keyword">let</span> bSum = B.reduce(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> preValue + curValue);</span><br><span class="line">    <span class="keyword">let</span> diff = (aSum - bSum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = new Set(A);</span><br><span class="line">    let res = [];</span><br><span class="line">    for (const y of B) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = y + diff;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.has(x)) &#123;</span><br><span class="line">            res = [x, y]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;888-公平的糖果棒交换&quot;&gt;&lt;a href=&quot;#888-公平的糖果棒交换&quot; class=&quot;headerlink&quot; title=&quot;888. 公平的糖果棒交换&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/fair-candy-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;888. 公平的糖果棒交换&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：&lt;code&gt;A[i]&lt;/code&gt; 是爱丽丝拥有的第 &lt;code&gt;i&lt;/code&gt; 根糖果棒的大小，&lt;code&gt;B[j]&lt;/code&gt; 是鲍勃拥有的第 &lt;code&gt;j&lt;/code&gt; 根糖果棒的大小。&lt;/p&gt;
&lt;p&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。&lt;em&gt;（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;返回一个整数数组 &lt;code&gt;ans&lt;/code&gt;，其中 &lt;code&gt;ans[0]&lt;/code&gt; 是爱丽丝必须交换的糖果棒的大小，&lt;code&gt;ans[1]&lt;/code&gt; 是 Bob 必须交换的糖果棒的大小。&lt;/p&gt;
&lt;p&gt;如果有多个答案，你可以返回其中任何一个。保证答案存在。&lt;br&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.28</title>
    <link href="https://lf2021.github.io/2021/01/28/lc2021.1.28/"/>
    <id>https://lf2021.github.io/2021/01/28/lc2021.1.28/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组 “<strong>中心索引</strong>” 的方法。</p><p>我们是这样定义数组 <strong>中心索引</strong> 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。<br><a id="more"></a></p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">索引 3 (nums[3] &#x3D; 6) 的左侧数之和 (1 + 7 + 3 &#x3D; 11)，与右侧数之和 (5 + 6 &#x3D; 11) 相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>nums 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code> 的整数。</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">计算所有数字的和为 total，记录左侧元素的和 sum，每次判断 2 * sum 加上当前元素是不是等于 total</span><br><span class="line"></span><br><span class="line">    是就直接返回当前索引</span><br><span class="line">    </span><br><span class="line">    否则遍历结束都没有就返回 -1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，n 为数组 nums 的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = nums.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] === total) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;724-寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#724-寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;724. 寻找数组的中心索引&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-pivot-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;724. 寻找数组的中心索引&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个整数类型的数组 &lt;code&gt;nums&lt;/code&gt;，请编写一个能够返回数组 “&lt;strong&gt;中心索引&lt;/strong&gt;” 的方法。&lt;/p&gt;
&lt;p&gt;我们是这样定义数组 &lt;strong&gt;中心索引&lt;/strong&gt; 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。&lt;/p&gt;
&lt;p&gt;如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。&lt;br&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.26</title>
    <link href="https://lf2021.github.io/2021/01/26/lc2021.1.26/"/>
    <id>https://lf2021.github.io/2021/01/26/lc2021.1.26/</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-01-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/" target="_blank" rel="noopener">1128. 等价多米诺骨牌对的数量</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p><p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p><p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a=c</code> 且 <code>b=d</code>，或是 <code>a=d</code> 且 <code>b=c</code>。</p><p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dominoes &#x3D; [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 ≤ dominoes.length ≤ 40000</li><li>1 ≤ dominoes[i][j] ≤ 9</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：排序-哈希map-计数"><a href="#方法1：排序-哈希map-计数" class="headerlink" title="方法1：排序 + 哈希map + 计数"></a>方法1：排序 + 哈希map + 计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 dominoes 数组中每一项按从小到大排个序变为字符串，然后哈希表记录下出每个字符串出现的次数，最后遍历哈希表即可得</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，n 是数组的长度。</li><li>空间复杂度：O(n)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numEquivDominoPairs = <span class="function"><span class="keyword">function</span>(<span class="params">dominoes</span>) </span>&#123;</span><br><span class="line">    dominoes = dominoes.map(<span class="function"><span class="params">e</span> =&gt;</span> e[<span class="number">0</span>] &lt; e[<span class="number">1</span>] ? <span class="string">''</span> + e[<span class="number">0</span>] + e[<span class="number">1</span>] : <span class="string">''</span> + e[<span class="number">1</span>] + e[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> dominoe <span class="keyword">of</span> dominoes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(dominoe)) &#123;</span><br><span class="line">            map.set(dominoe, map.get(dominoe) + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(dominoe, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    map.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        ret += value * (value - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法2：二元组表示-计数"><a href="#方法2：二元组表示-计数" class="headerlink" title="方法2：二元组表示 + 计数"></a>方法2：二元组表示 + 计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先我们直接让每一个二元对都变为指定的格式，即第一维必须不大于第二维。这样两个二元对「等价」当且仅当两个二元对完全相同。</span><br><span class="line"></span><br><span class="line">其次注意到二元对中的元素均不大于 9，因此我们可以将每一个二元对拼接成一个两位的正整数，即 (x,y) -&gt; 10x+y。</span><br><span class="line">这样就无需使用哈希表统计元素数量，而直接使用长度为 100 的数组即可。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，n 是数组的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numEquivDominoPairs = <span class="function"><span class="keyword">function</span> (<span class="params">dominoes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ele <span class="keyword">of</span> dominoes) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = ele[<span class="number">0</span>] &gt; ele[<span class="number">1</span>] ? <span class="number">10</span> * ele[<span class="number">1</span>] + ele[<span class="number">0</span>] : <span class="number">10</span> * ele[<span class="number">0</span>] + ele[<span class="number">1</span>];</span><br><span class="line">        arr[val]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        ret += n * (n - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1128-等价多米诺骨牌对的数量&quot;&gt;&lt;a href=&quot;#1128-等价多米诺骨牌对的数量&quot; class=&quot;headerlink&quot; title=&quot;1128. 等价多米诺骨牌对的数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1128. 等价多米诺骨牌对的数量&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给你一个由一些多米诺骨牌组成的列表 &lt;code&gt;dominoes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果其中某一张多米诺骨牌可以通过旋转 &lt;code&gt;0&lt;/code&gt; 度或 &lt;code&gt;180&lt;/code&gt; 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。&lt;/p&gt;
&lt;p&gt;形式上，&lt;code&gt;dominoes[i] = [a, b]&lt;/code&gt; 和 &lt;code&gt;dominoes[j] = [c, d]&lt;/code&gt; 等价的前提是 &lt;code&gt;a=c&lt;/code&gt; 且 &lt;code&gt;b=d&lt;/code&gt;，或是 &lt;code&gt;a=d&lt;/code&gt; 且 &lt;code&gt;b=c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; dominoes.length&lt;/code&gt; 的前提下，找出满足 &lt;code&gt;dominoes[i]&lt;/code&gt; 和 &lt;code&gt;dominoes[j]&lt;/code&gt; 等价的骨牌对 &lt;code&gt;(i, j)&lt;/code&gt; 的数量。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.24</title>
    <link href="https://lf2021.github.io/2021/01/24/lc2021.1.24/"/>
    <id>https://lf2021.github.io/2021/01/24/lc2021.1.24/</id>
    <published>2021-01-23T16:00:00.000Z</published>
    <updated>2021-01-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r（l &lt; r）</code>确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 ≤ nums.length ≤ $10^4$</li><li>-$10^9$ ≤ nums[i] ≤ $10^9$</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp矩阵的定义</span><br><span class="line">    dp[i] 定义为以 nums[i] 结尾的连续递增子序列的最大长度</span><br><span class="line"></span><br><span class="line">转移方程很好理解，dp[i-1] --&gt; dp[i]</span><br><span class="line">    如果 nums[i] &gt; nums[i-1]，那么 dp[i] &#x3D; dp[i-1] + 1，也就是与前面的组成连续递增子序列</span><br><span class="line">    否则的话，nums[i] 自成一组连续递增子序列，即 dp[i] &#x3D; 1</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</li><li>空间复杂度：O(n)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法2：贪心"><a href="#方法2：贪心" class="headerlink" title="方法2：贪心"></a>方法2：贪心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用一个 start 指针记录连续递增子序列的头部位置，初始时 start &#x3D; 0，然后遍历数组进行如下操作：</span><br><span class="line"></span><br><span class="line">    1. 如果下标 nums[i] ≤ nums[i−1]，则说明当前元素小于或等于上一个元素，因此 nums[i−1] 和 nums[i] 不可能属于同一个连续递增序列，</span><br><span class="line">    必须从下标 i 处开始一个新的连续递增序列，因此令 start&#x3D;i。如果下标 i&#x3D;0 或 nums[i] &gt; nums[i−1]，则不更新 start 的值。</span><br><span class="line"></span><br><span class="line">    2.此时下标范围 [start,i] 的连续子序列是递增序列，其长度为 i−start+1，使用当前连续递增序列的长度更新最长连续递增序列的长度。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">Math</span>.max(ret, i - start + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;674-最长连续递增序列&quot;&gt;&lt;a href=&quot;#674-最长连续递增序列&quot; class=&quot;headerlink&quot; title=&quot;674. 最长连续递增序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;674. 最长连续递增序列&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个未经排序的整数数组，找到最长且 &lt;strong&gt;连续递增的子序列&lt;/strong&gt;，并返回该序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续递增的子序列&lt;/strong&gt; 可以由两个下标 &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;r（l &amp;lt; r）&lt;/code&gt;确定，如果对于每个 &lt;code&gt;l &amp;lt;= i &amp;lt; r&lt;/code&gt;，都有 &lt;code&gt;nums[i] &amp;lt; nums[i + 1]&lt;/code&gt; ，那么子序列 &lt;code&gt;[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]&lt;/code&gt; 就是连续递增子序列。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.22</title>
    <link href="https://lf2021.github.io/2021/01/22/lc2021.1.22/"/>
    <id>https://lf2021.github.io/2021/01/22/lc2021.1.22/</id>
    <published>2021-01-21T16:00:00.000Z</published>
    <updated>2021-01-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>对于非负整数 <code>X</code> 而言，<code>X</code> 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为 <code>[1,2,3,1]</code>。</p><p>给定非负整数 <code>X</code> 的数组形式 <code>A</code>，返回整数 <code>X+K</code> 的数组形式。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,0,0], K &#x3D; 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 &#x3D; 1234</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 &#x3D; 455</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [2,1,5], K &#x3D; 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 &#x3D; 1021</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [9,9,9,9,9,9,9,9,9,9], K &#x3D; 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 &#x3D; 10000000000</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 ≤ A.length ≤ 10000</code></li><li><code>0 ≤ A[i] ≤ 9</code></li><li><code>0 ≤ K ≤ 10000</code></li><li><code>如果 A.length &gt; 1，那么 A[0] ≠ 0</code></li></ol><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="倒序逐位相加"><a href="#倒序逐位相加" class="headerlink" title="倒序逐位相加"></a>倒序逐位相加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">对数组 A 倒序遍历，每轮遍历的时候加上 K 对 10 取的余数，将和判断是否大于 10 后加入 ret 数组中，并对 K 进行更新。</span><br><span class="line"></span><br><span class="line">遍历完再对 K 做一个遍历直到 K &#x3D; 0 为止。</span><br><span class="line"></span><br><span class="line">例如：A &#x3D; [1, 2, 3]  K &#x3D; 912</span><br><span class="line">第一轮遍历： 3 + 2 &#x3D; 5，此时 K &#x3D; 91，ret &#x3D; [5]</span><br><span class="line">第二轮遍历： 2 + 1 &#x3D; 3，此时 K &#x3D; 9， ret &#x3D; [3, 5]</span><br><span class="line">第三轮遍历： 9 + 1 &#x3D; 10，此时 K &#x3D; 0 + 1 &#x3D; 1， ret &#x3D; [0, 3, 5]</span><br><span class="line">K &#x3D; 1，还要再向 ret 中加入 1，ret &#x3D; [1, 0, 3, 5]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($max\{m,n\}$)，其中 m 是数组 A 的长度，n 是数字 K 的长度</li><li>空间复杂度：O($max\{m,n\}$)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addToArrayForm = <span class="function"><span class="keyword">function</span> (<span class="params">A, K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = A[i] + K % <span class="number">10</span>;</span><br><span class="line">        K = <span class="built_in">Math</span>.floor(K / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            ret.unshift(sum % <span class="number">10</span>);</span><br><span class="line">            K++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.unshift(sum)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K = <span class="built_in">Math</span>.floor(K / <span class="number">10</span>)) &#123;</span><br><span class="line">        ret.unshift(K % <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;989-数组形式的整数加法&quot;&gt;&lt;a href=&quot;#989-数组形式的整数加法&quot; class=&quot;headerlink&quot; title=&quot;989. 数组形式的整数加法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-to-array-form-of-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;989. 数组形式的整数加法&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;对于非负整数 &lt;code&gt;X&lt;/code&gt; 而言，&lt;code&gt;X&lt;/code&gt; 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 &lt;code&gt;X = 1231&lt;/code&gt;，那么其数组形式为 &lt;code&gt;[1,2,3,1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定非负整数 &lt;code&gt;X&lt;/code&gt; 的数组形式 &lt;code&gt;A&lt;/code&gt;，返回整数 &lt;code&gt;X+K&lt;/code&gt; 的数组形式。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.20</title>
    <link href="https://lf2021.github.io/2021/01/20/lc2021.1.20/"/>
    <id>https://lf2021.github.io/2021/01/20/lc2021.1.20/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定的整型数组长度范围是 <code>[3,104]</code>，数组中所有的元素范围是 <code>[-1000, 1000]</code>。</li><li>输入的数组中任意三个数的乘积不会超出 <code>32</code> 位有符号整数的范围。</li></ol><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">先把数组按从小到大排个序,发现无非两种情况:</span><br><span class="line"></span><br><span class="line">1. 数组是纯负数,类似 [-4, -3, -2, -1]</span><br><span class="line">    最大乘积就应该是最大的几个数的乘积</span><br><span class="line"></span><br><span class="line">2. 数组不是纯负数,</span><br><span class="line">    (1)可能是纯正数,最大的乘积就是最大的几个数的乘积,类似于 [1, 2, 3, 4]</span><br><span class="line">    (2)可能是有正有负,那就判断一下最小的两个负数的乘积是不是要比次大的两个正数的乘积大,类似于[-5, -4, 1, 2, 3]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(nlogn)</li><li>空间复杂度:O(logn)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumProduct = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n - <span class="number">1</span>], nums[n - <span class="number">1</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">3</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;628-三个数的最大乘积&quot;&gt;&lt;a href=&quot;#628-三个数的最大乘积&quot; class=&quot;headerlink&quot; title=&quot;628. 三个数的最大乘积&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-product-of-three-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;628. 三个数的最大乘积&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.14</title>
    <link href="https://lf2021.github.io/2021/01/14/lc2021.1.14/"/>
    <id>https://lf2021.github.io/2021/01/14/lc2021.1.14/</id>
    <published>2021-01-13T16:00:00.000Z</published>
    <updated>2021-01-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1018-可被-5-整除的二进制前缀"><a href="#1018-可被-5-整除的二进制前缀" class="headerlink" title="1018. 可被 5 整除的二进制前缀"></a><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/" target="_blank" rel="noopener">1018. 可被 5 整除的二进制前缀</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>。我们定义 <code>N_i</code>：从 <code>A[0]</code> 到 <code>A[i]</code> 的第 <code>i</code> 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 <code>answer</code>，只有当 <code>N_i</code> 可以被 <code>5</code> 整除时，答案 <code>answer[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,1,1]</span><br><span class="line">输出：[true,false,false]</span><br><span class="line">解释：</span><br><span class="line">输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：[false,false,false]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,1,1,1,1,1]</span><br><span class="line">输出：[true,false,false,false,true,false]</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,0,1]</span><br><span class="line">输出：[false,false,false,false,false]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 ≤ A.length ≤ 30000</code></li><li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li></ol><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">对数组 [A[0], A[1], A[2]] 模拟一下这个过程： </span><br><span class="line"></span><br><span class="line">    第一个数N1：A[0]，然后对 5 去余判断是否为0</span><br><span class="line">    第二个数N2：A[0] * 2 + A[1]，然后对 5 去余判断是否为0</span><br><span class="line">    第三个数N3：A[0] * 4 + A[1] * 2 + A[2]，然后对 5 去余判断是否为0</span><br><span class="line"></span><br><span class="line">我们可以发现 N(i) &#x3D; N(i-1) * 2 + A[i-1]</span><br><span class="line"></span><br><span class="line">考虑到数组 A 可能很长，如果每次都保留 N(i) 的值，则可能导致溢出。</span><br><span class="line"></span><br><span class="line">但是因为只需要知道 N(i) 是否可以被 5 整除，因而我们可以每一轮只更新 N(i) % 5，结果不会影响，即</span><br><span class="line"></span><br><span class="line">N(i) &#x3D; (N(i-1) * 2 + A[i-1]) % 5</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($n$)，其中 n 是数组 A 的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefixesDivBy5 = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">let</span> len = A.length;</span><br><span class="line">    <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        prefix = (prefix * <span class="number">2</span> + A[i]) % <span class="number">5</span>;</span><br><span class="line">        ret.push(prefix === <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1018-可被-5-整除的二进制前缀&quot;&gt;&lt;a href=&quot;#1018-可被-5-整除的二进制前缀&quot; class=&quot;headerlink&quot; title=&quot;1018. 可被 5 整除的二进制前缀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1018. 可被 5 整除的二进制前缀&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成的数组 &lt;code&gt;A&lt;/code&gt;。我们定义 &lt;code&gt;N_i&lt;/code&gt;：从 &lt;code&gt;A[0]&lt;/code&gt; 到 &lt;code&gt;A[i]&lt;/code&gt; 的第 &lt;code&gt;i&lt;/code&gt; 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。&lt;/p&gt;
&lt;p&gt;返回布尔值列表 &lt;code&gt;answer&lt;/code&gt;，只有当 &lt;code&gt;N_i&lt;/code&gt; 可以被 &lt;code&gt;5&lt;/code&gt; 整除时，答案 &lt;code&gt;answer[i]&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，否则为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.13</title>
    <link href="https://lf2021.github.io/2021/01/13/lc2021.1.13/"/>
    <id>https://lf2021.github.io/2021/01/13/lc2021.1.13/</id>
    <published>2021-01-12T16:00:00.000Z</published>
    <updated>2021-01-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复<code>1, 2, ..., N</code>) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 <code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和 <code>v</code>的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着<code>N</code>个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>输入的二维数组大小在 3 到 1000。</li><li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</span><br><span class="line"></span><br><span class="line">树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。</span><br><span class="line"></span><br><span class="line">可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</span><br><span class="line"></span><br><span class="line">    • 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</span><br><span class="line"></span><br><span class="line">    • 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(NlogN)，其中 N 是图中的节点个数。</li><li>空间复杂度：O(N)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRedundantConnection = <span class="function"><span class="keyword">function</span> (<span class="params">edges</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodesCount = edges.length;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="built_in">Array</span>(nodesCount + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [node1, node2] = edges[i];</span><br><span class="line">        <span class="keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class="line">            union(parent, node1, node2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">parent, index1, index2</span>) =&gt;</span> &#123;</span><br><span class="line">    parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">parent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[index] !== index) &#123;</span><br><span class="line">        parent[index] = find(parent, parent[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;684-冗余连接&quot;&gt;&lt;a href=&quot;#684-冗余连接&quot; class=&quot;headerlink&quot; title=&quot;684. 冗余连接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/redundant-connection/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;684. 冗余连接&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;在本问题中, 树指的是一个连通且无环的无向图。&lt;/p&gt;
&lt;p&gt;输入一个图，该图由一个有着N个节点 (节点值不重复&lt;code&gt;1, 2, ..., N&lt;/code&gt;) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。&lt;/p&gt;
&lt;p&gt;结果图是一个以边组成的二维数组。每一个边的元素是一对 &lt;code&gt;[u, v]&lt;/code&gt; ，满足 &lt;code&gt;u &amp;lt; v&lt;/code&gt;，表示连接顶点 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt;的无向图的边。&lt;/p&gt;
&lt;p&gt;返回一条可以删去的边，使得结果图是一个有着&lt;code&gt;N&lt;/code&gt;个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 &lt;code&gt;[u, v]&lt;/code&gt; 应满足相同的格式 &lt;code&gt;u &amp;lt; v&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.10</title>
    <link href="https://lf2021.github.io/2021/01/10/lc2021.1.10/"/>
    <id>https://lf2021.github.io/2021/01/10/lc2021.1.10/</id>
    <published>2021-01-09T16:00:00.000Z</published>
    <updated>2021-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">228. 汇总区间</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <code>恰好覆盖数组中所有数字</code> 的 <code>最小有序</code> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 ≤ nums.length ≤ 20</code></li><li>-2<sup>31</sup> ≤ nums[i] ≤ 2<sup>31</sup>-1</li><li><code>nums 中的所有值都 互不相同</code></li><li><code>nums 按升序排列</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">一次遍历即可，遍历 nums[i]，判断 nums[i+1] 是不是比 nums[i] 大 1:</span><br><span class="line"></span><br><span class="line">    如果是说明形成一个区间，继续往后找，知道找一个数 nums[j] 不满足条件，这个时候 [i, j] 区间内的数就是一个区间，区间就是 nums[i] -&gt; nums[j]]</span><br><span class="line"></span><br><span class="line">    如果不是就说明这个数就是一个区间 nums[i]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($n$)，其中 n 是数组 nums 的长度。</li><li>空间复杂度：O(1)，除了用于输出的空间外，额外使用的空间为常数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> summaryRanges = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] + <span class="number">1</span> === nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] + <span class="number">1</span> === nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push([nums[i], nums[j]].join(<span class="string">'-&gt;'</span>))</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.push(<span class="string">''</span> + nums[i])</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;228-汇总区间&quot;&gt;&lt;a href=&quot;#228-汇总区间&quot; class=&quot;headerlink&quot; title=&quot;228. 汇总区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/summary-ranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;228. 汇总区间&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回 &lt;code&gt;恰好覆盖数组中所有数字&lt;/code&gt; 的 &lt;code&gt;最小有序&lt;/code&gt; 区间范围列表。也就是说，&lt;code&gt;nums&lt;/code&gt; 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 &lt;code&gt;nums&lt;/code&gt; 的数字 &lt;code&gt;x&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.9</title>
    <link href="https://lf2021.github.io/2021/01/09/lc2021.1.9/"/>
    <id>https://lf2021.github.io/2021/01/09/lc2021.1.9/</id>
    <published>2021-01-08T16:00:00.000Z</published>
    <updated>2021-01-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 ≤ prices.length ≤ 105</code></li><li><code>0 ≤ prices[i] ≤ 105</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>题解：</p><p>在任意一天结束后，我们会处于五种状态中的一种：</p><ul><li>未进行任何操作</li><li>只进行了一次买操作</li><li>只进行一次买操作和一次卖操作，即完成了一笔交易</li><li>在完成了一笔交易的前提下，进行了第二次买操作</li><li>完成了两笔交易</li></ul><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 $buy_1$, $sell_1$, $buy_2$, $sell_2$</p><p>状态转移，知道第 <code>i-1</code> 天结束后的这四个状态，第 <code>i</code> 天的状态：</p><ul><li>对于 $buy_1$</li></ul><p>在第 <code>i</code> 天可以不进行任何操作，保持不变，也可以在未进行任何操作的前提下以 <code>prices[i]</code> 的价格买入股票，转移方程为：</p><script type="math/tex; mode=display">buy_1(i) = max\{buy_1(i-1), -prices[i]\}</script><p>其中，$buy_1(i)$ 表示 <code>i</code> 天的状态，$buy_1(i-1)$ 表示 <code>i-1</code> 天的状态，下面也是类似。</p><ul><li>对于 $sell_1$</li></ul><p>在第 <code>i</code> 天我们可以不进行任何操作，保持不变，也可以在只进行过一次买操作的前提下以 <code>prices[i]</code> 的价格卖出股票，转移方程为：</p><script type="math/tex; mode=display">sell_1(i) = max\{sell_1(i-1), buy_1(i)+prices[i]\}</script><ul><li>对于 $buy_2$</li></ul><p>同理转移方程为：</p><script type="math/tex; mode=display">buy_2(i) = max\{buy_2(i-1), sell_1(i)-prices[i]\}</script><ul><li>对于 $sell_2$</li></ul><p>同理转移方程为：</p><script type="math/tex; mode=display">sell_2(i) = max\{sell_2(i-1), buy_2(i)+prices[i]\}</script><p>理论上，我们需要维护四个数组  $buy_1[i]$ , $sell_1[i]$ , $buy_2[i]$ , $sell_2[i]$ ，但是因为每个状态只与前一天的状态有关，因而我们可以进一步降低空间复杂度，我们只需维护四个变量：$buy_1$ , $sell_1$ , $buy_2$ , $sell_2$，然后不断的更新这四个变量即可。</p><ul><li>总的状态转移方程为：</li></ul><script type="math/tex; mode=display">\begin{cases}    buy_1 = max\{buy_1, -prices[i]\}\\    sell_1 = max\{sell_1, buy_1+prices[i]\}\\    buy_2 = max\{buy_2, sell_1-prices[i]\}\\    sell_2 = max\{sell_2, buy_2+prices[i]\}\end{cases}</script><ul><li>时间复杂度：O($n$)，其中 n 是数组 prices 的长度。</li><li>空间复杂度：O(1)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = prices.length;</span><br><span class="line">    <span class="keyword">let</span> buy1 = -prices[<span class="number">0</span>], buy2 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy1 = <span class="built_in">Math</span>.max(buy1, -prices[i])</span><br><span class="line">        sell1 = <span class="built_in">Math</span>.max(sell1, buy1 + prices[i])</span><br><span class="line">        buy2 = <span class="built_in">Math</span>.max(buy2, sell1 - prices[i])</span><br><span class="line">        sell2 = <span class="built_in">Math</span>.max(sell2, buy2 + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;123-买卖股票的最佳时机-III&quot;&gt;&lt;a href=&quot;#123-买卖股票的最佳时机-III&quot; class=&quot;headerlink&quot; title=&quot;123. 买卖股票的最佳时机 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;123. 买卖股票的最佳时机 III&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 &lt;code&gt;i&lt;/code&gt; 个元素是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;两笔&lt;/strong&gt; 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.8</title>
    <link href="https://lf2021.github.io/2021/01/08/lc2021.1.8/"/>
    <id>https://lf2021.github.io/2021/01/08/lc2021.1.8/</id>
    <published>2021-01-07T16:00:00.000Z</published>
    <updated>2021-01-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个数组，将数组中的元素向右移动 $k$ 个位置，其中 $k$ 是非负数。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法。</li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">循环 k 次：将数组最后一个元素弹出，添加到数组头部</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($k*n$)，n 为数组的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums.unshift(nums.pop())</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">当我们将数组的元素向右移动 k 次后，尾部 k%n 个元素会移动至数组头部，其余元素向后移动 k%n 个位置。</span><br><span class="line"></span><br><span class="line">我们可以先将所有元素翻转，这样尾部的 k%n 个元素就被移至数组头部，然后我们再翻转 [0, k%n-1] 区间的元素和 [k%n, n-1] 区间的元素即能得到最后的答案。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($n$)，n 是城市的个数。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function">(<span class="params">nums, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            [nums[start], nums[end]] = [nums[end], nums[start]]</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    k = k % n;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">    reverse(nums, k, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;189-旋转数组&quot;&gt;&lt;a href=&quot;#189-旋转数组&quot; class=&quot;headerlink&quot; title=&quot;189. 旋转数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;189. 旋转数组&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 $k$ 个位置，其中 $k$ 是非负数。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.7</title>
    <link href="https://lf2021.github.io/2021/01/07/lc2021.1.7/"/>
    <id>https://lf2021.github.io/2021/01/07/lc2021.1.7/</id>
    <published>2021-01-06T16:00:00.000Z</published>
    <updated>2021-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">547. 省份数量</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><a id="more"></a><p><strong>示例1：</strong></p><p><img data-src="/images/loading.gif" data-original="/images/202101071.jpg" alt="示例1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img data-src="/images/loading.gif" data-original="/images/202101072.jpg" alt="示例1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 ≤ n ≤ 200</code></li><li><code>n = isConnected.length</code></li><li><code>n = isConnected[i].length</code></li><li><code>isConnected[i][j] 为 1 或 0</code></li><li><code>isConnected[i][i] = 1</code></li><li><code>isConnected[i][j] = isConnected[j][i]</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><p>可以把 n 个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，给定的矩阵 isConnected 即为图的邻接矩阵，省份即为图中的连通分量。</p><p>计算省份总数，等价于计算图中的连通分量数，可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，</span><br><span class="line"></span><br><span class="line">通过矩阵 isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，</span><br><span class="line"></span><br><span class="line">直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($n^2$)，n 是城市的个数。</li><li>空间复杂度：O($n$)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span> (<span class="params">isConnected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">isConnected, visited, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] === <span class="number">1</span> &amp;&amp; !visited.has(j)) &#123; <span class="comment">// 城市 i 和 j 相连，并且 j 没有并访问过</span></span><br><span class="line">                visited.add(j);</span><br><span class="line">                dfs(isConnected, visited, j) <span class="comment">// 继续遍历和城市j相连的城市，标记已访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(i)) &#123; <span class="comment">// 城市 i 没有被访问过</span></span><br><span class="line">            dfs(isConnected, visited, i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">通过广度优先搜索的方法得到省份的总数。对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，</span><br><span class="line"></span><br><span class="line">直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($n^2$)，n 是城市的个数。</li><li>空间复杂度：O($n$)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span> (<span class="params">isConnected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(i)) &#123;</span><br><span class="line">            queue.push(i)</span><br><span class="line">            <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">                <span class="keyword">let</span> j = queue.shift();</span><br><span class="line">                visited.add(j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isConnected[j][k] === <span class="number">1</span> &amp;&amp; !visited.has(k)) &#123;</span><br><span class="line">                        queue.push(k)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;547-省份数量&quot;&gt;&lt;a href=&quot;#547-省份数量&quot; class=&quot;headerlink&quot; title=&quot;547. 省份数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-provinces/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;547. 省份数量&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个城市，其中一些彼此相连，另一些没有相连。如果城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;b&lt;/code&gt; 直接相连，且城市 &lt;code&gt;b&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 直接相连，那么城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 间接相连。&lt;/p&gt;
&lt;p&gt;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;p&gt;给你一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵 &lt;code&gt;isConnected&lt;/code&gt; ，其中 &lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个城市和第 &lt;code&gt;j&lt;/code&gt; 个城市直接相连，而 &lt;code&gt;isConnected[i][j] = 0&lt;/code&gt; 表示二者不直接相连。&lt;/p&gt;
&lt;p&gt;返回矩阵中 省份 的数量。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.6</title>
    <link href="https://lf2021.github.io/2021/01/06/lc2021.1.6/"/>
    <id>https://lf2021.github.io/2021/01/06/lc2021.1.6/</id>
    <published>2021-01-05T16:00:00.000Z</published>
    <updated>2021-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong><br>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">问题：a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;]], values &#x3D; [0.5], queries &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">输出：[0.50000,2.00000,-1.00000,-1.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 ≤ equations.length ≤ 20</code></li><li><code>equations[i].length = 2</code></li><li><code>1 ≤ Ai.length, Bi.length ≤ 5</code></li><li><code>values.length = equations.length</code></li><li><code>0.0 &lt; values[i] ≤ 20.0</code></li><li><code>1 ≤ queries.length ≤ 20</code></li><li><code>queries[i].length = 2</code></li><li><code>1 ≤ Cj.length, Dj.length ≤ 5</code></li><li><code>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">我们将这种关系表示为存储为邻接表</span><br><span class="line"></span><br><span class="line">如下图这种关系我们将其保存为如下邻接表格式：</span><br><span class="line"></span><br><span class="line">map &#x3D; &#123;</span><br><span class="line">    a: &#123; b: 2 &#125;,</span><br><span class="line">    b: &#123; a: 1&#x2F;2, c: 3 &#125;,</span><br><span class="line">    c: &#123; b: 1&#x2F;3 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后我们再扩展出所有可能的情况，例如 a&#x2F;b 和 b&#x2F;c 可以扩展到 a&#x2F;c</span><br><span class="line"></span><br><span class="line">最后只要对 queries 数组遍历得到结果即可</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="/images/leetcode2021.1.6.png" alt="关系图"></p><ul><li>时间复杂度：O($n^3$)，n 是所有可能的字符的个数。</li><li>空间复杂度：O($n$)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calcEquation = <span class="function"><span class="keyword">function</span> (<span class="params">equations, values, queries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义一个对象，map[x][y] 表示 x/y 的值</span></span><br><span class="line">    equations.forEach(<span class="function">(<span class="params">e, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map[e[<span class="number">0</span>]]) map[e[<span class="number">0</span>]] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!map[e[<span class="number">1</span>]]) map[e[<span class="number">1</span>]] = &#123;&#125;;</span><br><span class="line">        map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = values[i]</span><br><span class="line">        map[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span> / values[i]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(map);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">        keys.forEach(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            map[x][y] &amp;&amp; keys.forEach(<span class="function"><span class="params">z</span> =&gt;</span> &#123; <span class="comment">// 如果 x/y 有值 y/z 也有值，则 x/z 的值也可以求出</span></span><br><span class="line">                <span class="keyword">if</span> (map[y][z]) &#123;</span><br><span class="line">                    map[x][z] = map[x][y] * map[y][z]</span><br><span class="line">                    map[z][x] = <span class="number">1</span> / map[x][z] <span class="comment">// 这行不加会有一个测试案例通过不了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> queries.map(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map[e[<span class="number">0</span>]] &amp;&amp; map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] ? map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] : <span class="number">-1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;399-除法求值&quot;&gt;&lt;a href=&quot;#399-除法求值&quot; class=&quot;headerlink&quot; title=&quot;399. 除法求值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/evaluate-division/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;399. 除法求值&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;给你一个变量对数组 &lt;code&gt;equations&lt;/code&gt; 和一个实数值数组 &lt;code&gt;values&lt;/code&gt; 作为已知条件，其中 &lt;code&gt;equations[i] = [Ai, Bi]&lt;/code&gt; 和 &lt;code&gt;values[i]&lt;/code&gt; 共同表示等式 &lt;code&gt;Ai / Bi = values[i]&lt;/code&gt; 。每个 &lt;code&gt;Ai&lt;/code&gt; 或 &lt;code&gt;Bi&lt;/code&gt; 是一个表示单个变量的字符串。&lt;/p&gt;
&lt;p&gt;另有一些以数组 &lt;code&gt;queries&lt;/code&gt; 表示的问题，其中 &lt;code&gt;queries[j] = [Cj, Dj]&lt;/code&gt; 表示第 &lt;code&gt;j&lt;/code&gt; 个问题，请你根据已知条件找出 &lt;code&gt;Cj / Dj = ?&lt;/code&gt; 的结果作为答案。&lt;/p&gt;
&lt;p&gt;返回 所有问题的答案 。如果存在某个无法确定的答案，则用 &lt;code&gt;-1.0&lt;/code&gt; 替代这个答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.5</title>
    <link href="https://lf2021.github.io/2021/01/05/lc2021.1.5/"/>
    <id>https://lf2021.github.io/2021/01/05/lc2021.1.5/</id>
    <published>2021-01-04T16:00:00.000Z</published>
    <updated>2021-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">我们可以遍历该序列，并记录当前分组的长度。如果下一个字符与当前字符不同，或者已经枚举到字符串尾部，就说明当前字符为当前分组的尾部。</span><br><span class="line"></span><br><span class="line">每次找到当前分组的尾部时，如果该分组长度达到 3，我们就将其加入答案。</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，n 是 s 的长度。</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> largeGroupPositions = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === n<span class="number">-1</span> || s[i+<span class="number">1</span>] !== s[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                res.push([i - num + <span class="number">1</span>, i])</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;830-较大分组的位置&quot;&gt;&lt;a href=&quot;#830-较大分组的位置&quot; class=&quot;headerlink&quot; title=&quot;830. 较大分组的位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/positions-of-large-groups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;830. 较大分组的位置&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;p&gt;例如，在字符串 &lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt; 中，就含有 &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;z&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;yy&amp;quot;&lt;/code&gt; 这样的一些分组。&lt;/p&gt;
&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt; 表示，其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题2020.1.4</title>
    <link href="https://lf2021.github.io/2021/01/04/lc2021.1.4/"/>
    <id>https://lf2021.github.io/2021/01/04/lc2021.1.4/</id>
    <published>2021-01-03T16:00:00.000Z</published>
    <updated>2021-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p><strong>斐波那契数</strong>，通常用 F(n) 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><a id="more"></a><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 ≤ n ≤ 30</code></li></ul><h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：通项公式"><a href="#方法1：通项公式" class="headerlink" title="方法1：通项公式"></a>方法1：通项公式</h4><p>斐波那契数 F(n) 是齐次线性递推，根据递推方程 F(n)=F(n-1)+F(n-2)，可以写出这样的特征方程：</p><script type="math/tex; mode=display">x ^ 2=x+1</script><p>求得$x_1=\frac{1+\sqrt5}{2}$，$x_2=\frac{1-\sqrt5}{2}$。设通解为$F(n)=c_1x_1^n+c_2x_2^n$，代入初始条件$F(n)=0, F(1)=1$，得$c_1=\frac{1}{\sqrt5}，c_2=-\frac{1}{\sqrt5}$。因此斐波那契数得通项公式如下：</p><script type="math/tex; mode=display">    F(n)=\frac{1}{\sqrt5}    \left[        \left(            \frac{1+\sqrt5}{2}        \right)^n-        \left(\frac{1-\sqrt5}{2}        \right)^n    \right]</script><p>得到通项公式之后，就可以通过公式直接求解第 n 项。</p><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> fibN = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(fibN / sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法2：循环法"><a href="#方法2：循环法" class="headerlink" title="方法2：循环法"></a>方法2：循环法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数的特点就是当前的数等于前两个树之和，那我们可以用三个变量 a b res 分别表示第一个数、第二个数、第三个数</span><br><span class="line"></span><br><span class="line">然后在循环的时候不断更新即可</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">-1</span>, b = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        res = a+b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法3：动态规划"><a href="#方法3：动态规划" class="headerlink" title="方法3：动态规划"></a>方法3：动态规划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp 矩阵的定义：</span><br><span class="line">    dp[i] 定义为第 i 个数</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line">    dp[i] &#x3D; dp[i-1] + dp[i-2]</span><br><span class="line"></span><br><span class="line">目标：</span><br><span class="line">    dp[n]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法4：递归法"><a href="#方法4：递归法" class="headerlink" title="方法4：递归法"></a>方法4：递归法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们要求 fib(n) ，那就是要求 fib(n-1) 和 fib(n-2)，依次下去...</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O($2^n$)</li><li>空间复杂度：O(1)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n===<span class="number">0</span> || n===<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;509-斐波那契数&quot;&gt;&lt;a href=&quot;#509-斐波那契数&quot; class=&quot;headerlink&quot; title=&quot;509. 斐波那契数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;509. 斐波那契数&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、题目&quot;&gt;&lt;a href=&quot;#一、题目&quot; class=&quot;headerlink&quot; title=&quot;一、题目&quot;&gt;&lt;/a&gt;一、题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 F(n) 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://lf2021.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode每日一题" scheme="https://lf2021.github.io/tags/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo中启用mathjax的方式</title>
    <link href="https://lf2021.github.io/2021/01/04/hexo%E4%BD%BF%E7%94%A8mathjax/"/>
    <id>https://lf2021.github.io/2021/01/04/hexo%E4%BD%BF%E7%94%A8mathjax/</id>
    <published>2021-01-03T16:00:00.000Z</published>
    <updated>2021-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo中如何正确使用mathjax"><a href="#hexo中如何正确使用mathjax" class="headerlink" title="hexo中如何正确使用mathjax"></a>hexo中如何正确使用mathjax</h2><p>今天我在使用hexo写博客的时候，惊讶的发现md文档写的mathjax公式在vscode编辑器上预览是可以正常显示的，但是在部署到博客上时却未能正确显示，按照如下5个步骤操作，即可实现</p><a id="more"></a><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="一、使用-kramed-代替-marked"><a href="#一、使用-kramed-代替-marked" class="headerlink" title="一、使用 kramed 代替 marked"></a>一、使用 kramed 代替 marked</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo默认使用hexo-renderer-marked引擎去渲染网页，它会把利用Markdown语法写的文本去转换为相应的html标签。</span><br><span class="line"></span><br><span class="line">在利用Markdown写MathJax公式的时候，经常会用到下划线_表示下标，但是下划线_会被hexo的默认引擎hexo-renderer-marked渲染成html中的&lt;em&gt;标签，表示斜体，</span><br><span class="line"></span><br><span class="line">这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</span><br></pre></td></tr></table></figure><ul><li><strong>卸载marked，改装kramed</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ul><li><strong>更改相应的规则</strong></li></ul><p>找到根目录下的 <strong><code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code></strong> 文件</p><p><strong>找到以下内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改为</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、使用-hexo-renderer-mathjax-代替-hexo-math"><a href="#二、使用-hexo-renderer-mathjax-代替-hexo-math" class="headerlink" title="二、使用 hexo-renderer-mathjax 代替 hexo-math"></a>二、使用 hexo-renderer-mathjax 代替 hexo-math</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure><h4 id="三、更新-Mathjax-的-CDN-链接"><a href="#三、更新-Mathjax-的-CDN-链接" class="headerlink" title="三、更新 Mathjax 的 CDN 链接"></a>三、更新 Mathjax 的 CDN 链接</h4><p>找到根目录下的 <strong><code>/node_modules/hexo-renderer-mathjax/mathjax.html</code></strong> 文件，将最后的 script 标签改成如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="四、更改默认转义规则"><a href="#四、更改默认转义规则" class="headerlink" title="四、更改默认转义规则"></a>四、更改默认转义规则</h4><p>找到根目录下的 <strong><code>/node_modules/kramed/lib/rules/inline.js</code></strong> 文件</p><p><strong>将第 11 行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p><strong>改成</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p><strong>将第 21 行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p><strong>改成</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h4 id="五、开启mathjax"><a href="#五、开启mathjax" class="headerlink" title="五、开启mathjax"></a>五、开启mathjax</h4><p>先打开主题的配置文件，以 next 主题为例，打开<code>\theme\next\_config.yml</code>，搜索mathjax，设置成如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>在文章的 Front-matter 里打开 mathjax 开关</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: hexo中启用 mathjax 的方式</span><br><span class="line">date: 2021-1-4</span><br><span class="line">mathjax: true # 启用 mathjax</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>md 文档中使用 mathjax 语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$F(n)&#x3D;\frac&#123;1&#125;&#123;\sqrt5&#125;\left[\left(\frac&#123;1+\sqrt5&#125;&#123;2&#125;\right)^n-\left(\frac&#123;1-\sqrt5&#125;&#123;2&#125;\right)^n\right]$$</span><br></pre></td></tr></table></figure><p><strong>显示效果</strong></p><script type="math/tex; mode=display">F(n)=\frac{1}{\sqrt5}\left[\left(\frac{1+\sqrt5}{2}\right)^n-\left(\frac{1-\sqrt5}{2}\right)^n\right]</script><p>至此大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;hexo中如何正确使用mathjax&quot;&gt;&lt;a href=&quot;#hexo中如何正确使用mathjax&quot; class=&quot;headerlink&quot; title=&quot;hexo中如何正确使用mathjax&quot;&gt;&lt;/a&gt;hexo中如何正确使用mathjax&lt;/h2&gt;&lt;p&gt;今天我在使用hexo写博客的时候，惊讶的发现md文档写的mathjax公式在vscode编辑器上预览是可以正常显示的，但是在部署到博客上时却未能正确显示，按照如下5个步骤操作，即可实现&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://lf2021.github.io/categories/hexo/"/>
    
    
    <category term="hexo爬坑" scheme="https://lf2021.github.io/tags/hexo%E7%88%AC%E5%9D%91/"/>
    
  </entry>
  
</feed>
