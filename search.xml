<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac配置多个SSH账号</title>
    <url>/2020/06/23/MAC%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AASSH/</url>
    <content><![CDATA[<h2 id="MAC配置SSH密钥"><a href="#MAC配置SSH密钥" class="headerlink" title="MAC配置SSH密钥"></a>MAC配置SSH密钥</h2><p>众所周知，我们可以将代码托管到线上很多平台，gitee / github / gitlab 等等。<br>在企业中我们可能会遇到这种情况：</p>
<blockquote>
<p>企业的项目是放在gitlab上托管的，我需要为gitlab配置一个SSH密钥，但是我自己的项目是放到github上的，我需要为github也配置一个SSH密钥，这就涉及到了管理多个SSH密钥的问题，下面我分别介绍了配置单个和多个SSH密钥的方式。</p>
</blockquote>
<a id="more"></a>
<h3 id="一、配置单个SSH密钥"><a href="#一、配置单个SSH密钥" class="headerlink" title="一、配置单个SSH密钥"></a>一、配置单个SSH密钥</h3><p>例如：为企业gitlab配置SSH密钥<br>在终端中依次输入如下命令：</p>
<ol>
<li><p>注意这里邮箱是你公司的地址，敲完一路回车就好</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourmail@gmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到.ssh目录下，查看一下目录下的文件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看公钥（id_rsa.pub），复制下来，打开gitlab的Settings里的SSH Keys将复制的添加进去，会自动生成Title为你的邮箱。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>将私钥（id_rsa）添加到SSH-agent</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SSH-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、配置多个SSH密钥"><a href="#二、配置多个SSH密钥" class="headerlink" title="二、配置多个SSH密钥"></a>二、配置多个SSH密钥</h3><p>在这里我需要再为github配置一下SSH，如果重复上面的步骤，会出现密钥覆盖的情况，所以我们需要为新的密钥文件设置新的名字，步骤如下：</p>
<ol>
<li><p>这里邮箱是你注册github的邮箱，<strong>注意第一次回车之后需要为生成的密钥自定义名字</strong>，输入一个id_rsa_github，输入完之后一路回车</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourmail@gmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一下自己生成的SSH</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p> 目录下的文件应该有这些：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id_rsa.pub        id_rsa_github.pub        id_rsa            id_rsa_github     known_hosts</span><br></pre></td></tr></table></figure>
<p> 这里id_rsa和id_rsa.pub是我的gitlab的私钥和公钥，id_rsa_github和id_rsa_github.pub是我的github的私钥和公钥。</p>
</li>
<li><p>查看公钥（id_rsa_github.pub）,打开github的Settings里的SSH and GPG keys，New SSH key，将公钥复制进去，设置Title为你的邮箱名。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa_github.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加私钥</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件</p>
</li>
</ol>
<ul>
<li><p>在.ssh/下创建config文件</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure>
</li>
<li><p>用vim编辑器打开config，输入i切换到插入模式进行修改</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure>
<p>  在config中输入一下内容</p>
<blockquote>
<p>注意：如果Gitlab是用的公司的服务器，需要在HostName中指定公司的域名。</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gitlab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三、至此大功告成"><a href="#三、至此大功告成" class="headerlink" title="三、至此大功告成"></a>三、至此大功告成</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客填坑</title>
    <url>/2020/07/06/Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="切换-Next-主题"><a href="#切换-Next-主题" class="headerlink" title="切换 Next 主题"></a>切换 Next 主题</h2><ol>
<li>找到这个 next 主题的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">GitHub 网站</a></li>
<li><p>进入你的博客本地路径，例如我的是放在 D 盘下，然后将主题 clone 到本地</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd D:\myblog\blog</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
 <a id="more"></a></li>
<li><p>修改配置文件<br>打开根目录下的·<code>_config.yml</code> 的站点配置文件，找到themes的配置项，修改为next</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
</li>
<li><p>调试、发布</p>
<p> 输入调试指令，在浏览器中输入localhost:4000查看</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server --debug</span><br></pre></td></tr></table></figure>
<p> 在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p> 如出现缓存引起的异常，可以在生成命令前执行清除缓存命令</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="Hexo-部署-Next-主题网页字体不生效"><a href="#Hexo-部署-Next-主题网页字体不生效" class="headerlink" title="Hexo 部署 Next 主题网页字体不生效"></a>Hexo 部署 Next 主题网页字体不生效</h2><p>说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">hexo 下的 _config.yml 称为站点配置文件</span><br><span class="line">themes/next 中的_config.yml 称为主题配置文件</span><br></pre></td></tr></table></figure>
<ol>
<li><p>按照hexo 的官方文档，在站点配置文件设置语言（第7行）</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Lee</span> <span class="string">的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'进击的技术客'</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'Everything will be ok!'</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">'努力一片天'</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Lee</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样还是不起作用的话,请查看 <code>theme/next/languages/</code> 目录下是否有 <code>zh-Hans.yml</code> 文件.一般是有 <code>zh-CN.yml</code> ，所以要把 <code>zh-CN.yml</code> 文件改成名字为 <code>zh-Hans.yml</code> 就可以了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo爬坑</tag>
      </tags>
  </entry>
  <entry>
    <title>React自定义主题配置</title>
    <url>/2021/03/07/2021.3.7React%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="React-自定义-antd-主题方法编译失败与解决办法"><a href="#React-自定义-antd-主题方法编译失败与解决办法" class="headerlink" title="React 自定义 antd 主题方法编译失败与解决办法"></a>React 自定义 antd 主题方法编译失败与解决办法</h2><h3 id="一、按照官网操作"><a href="#一、按照官网操作" class="headerlink" title="一、按照官网操作"></a>一、按照官网操作</h3><p>首先我是按照<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener"><strong>官网的步骤</strong></a>一步一步操作下来的：</p>
<ol>
<li><p>安装 <code>less</code> 和 <code>less-loader</code></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install less less-loader</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入 <code>customize-cra</code> 中提供的 <code>less</code> 相关的函数 <code>addLessLoader</code> 来帮助加载 <code>less</code> 样式，同时修改 <code>config-overrides.js</code> 文件如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置具体的修改规则</span></span><br><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports,addLessLoader&#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd'</span>,</span><br><span class="line">    libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
</ol>
<h3 id="二、出现的问题"><a href="#二、出现的问题" class="headerlink" title="二、出现的问题"></a>二、出现的问题</h3><ol>
<li><p><code>addLessLoader</code> 这块出现以下问题</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">ValidationError: <span class="title">Invalid</span> <span class="title">options</span> <span class="title">object</span>. <span class="title">Less</span> <span class="title">Loader</span> <span class="title">has</span> <span class="title">been</span> <span class="title">initialized</span> <span class="title">using</span> <span class="title">an</span> <span class="title">options</span> <span class="title">object</span></span></span><br><span class="line"><span class="function"><span class="title">that</span> <span class="title">does</span> <span class="title">not</span> <span class="title">match</span> <span class="title">the</span> <span class="title">API</span> <span class="title">schema</span>.</span></span><br><span class="line"><span class="function">- <span class="title">options</span> <span class="title">has</span> <span class="title">a</span> <span class="title">unknown</span> <span class="title">property</span> '<span class="title">modifyVars</span>'. <span class="title">These</span> <span class="title">properties</span> <span class="title">are</span> <span class="title">valid</span>: </span></span><br><span class="line"><span class="function"><span class="title">object</span> &#123; <span class="title">lessOptions</span>?, <span class="title">additonalData</span>?, <span class="title">sourceMap</span>?, <span class="title">webpackImporter</span>? &#125;</span></span><br></pre></td></tr></table></figure>
<p> 这是由于 <code>less</code> 更新了导致的，解决办法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addLessLoader(&#123;</span><br><span class="line">  lessOptions:&#123;  </span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译出错如下</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">TypeError: <span class="title">this.getOptions</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span> <span class="title">function</span></span></span><br></pre></td></tr></table></figure>
<p> 解决方案：我装的都是最新版本<code>less@4.1.1</code> <code>less-loader@8.0.0</code> ，我们需要降低版本，亲测以下两个版本可以。</p>
<ul>
<li><p>先卸载 <code>less</code> 和 <code>less-loader</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm uninstall less less-loader</span><br></pre></td></tr></table></figure>
</li>
<li><p>再安装指定版本</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i less@<span class="number">3</span>.<span class="number">12</span>.<span class="number">2</span> less-loader@<span class="number">7</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>前端技术更新太快的同时就会带来不兼容的问题，我们能做的就是<strong>乐在其中</strong>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github上md文件[toc]无法创建目录的问题</title>
    <url>/2020/07/04/github%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="解决GitHub上md文件-toc-无法创建目录的问题"><a href="#解决GitHub上md文件-toc-无法创建目录的问题" class="headerlink" title="解决GitHub上md文件[toc]无法创建目录的问题"></a>解决GitHub上md文件[toc]无法创建目录的问题</h2><p>熟悉markdown都知道可以使用<code>[TOC]</code>来自动生成markdown文件的标题目录，但是GitHub却不支持<code>[TOC]</code>标签</p>
<p>因此这里介绍一种插件方法一键生成目录</p>
<p><strong>注意</strong>：这里只是针对 VScode 用户</p>
<a id="more"></a>
<hr>
<h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><ul>
<li>1.安装<code>Markdown All in One</code>这个插件 (看下载量就知道好不好了😊)</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="/images/markdown插件.png" alt="Markdown All in One"></p>
<ul>
<li>2.对于你要生成目录的md文件，使用VScode快捷键 ctrl + shift + p 打开界面如下：</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="/images/生成目录.png" alt="Markdown all in one插件操作"></p>
<ul>
<li>3.然后输入 <code>Markdown All in One: Create Table of Contents</code> 回车即可生成目录，是不是很方便呢</li>
</ul>
<p>上传至GitHub上也亲测有效哦</p>
<h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><ol>
<li>安装vscode插件 Markdown All in One</li>
<li>快捷键 ctrl + shift + p 打开后输入<code>Markdown All in One: Create Table of Contents</code></li>
<li>over(●’◡’●)</li>
</ol>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中启用mathjax的方式</title>
    <url>/2021/01/04/hexo%E4%BD%BF%E7%94%A8mathjax/</url>
    <content><![CDATA[<h2 id="hexo中如何正确使用mathjax"><a href="#hexo中如何正确使用mathjax" class="headerlink" title="hexo中如何正确使用mathjax"></a>hexo中如何正确使用mathjax</h2><p>今天我在使用hexo写博客的时候，惊讶的发现md文档写的mathjax公式在vscode编辑器上预览是可以正常显示的，但是在部署到博客上时却未能正确显示，按照如下5个步骤操作，即可实现</p>
<a id="more"></a>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="一、使用-kramed-代替-marked"><a href="#一、使用-kramed-代替-marked" class="headerlink" title="一、使用 kramed 代替 marked"></a>一、使用 kramed 代替 marked</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo默认使用hexo-renderer-marked引擎去渲染网页，它会把利用Markdown语法写的文本去转换为相应的html标签。</span><br><span class="line"></span><br><span class="line">在利用Markdown写MathJax公式的时候，经常会用到下划线_表示下标，但是下划线_会被hexo的默认引擎hexo-renderer-marked渲染成html中的&lt;em&gt;标签，表示斜体，</span><br><span class="line"></span><br><span class="line">这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>卸载marked，改装kramed</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>更改相应的规则</strong></li>
</ul>
<p>找到根目录下的 <strong><code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code></strong> 文件</p>
<p><strong>找到以下内容</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>改为</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、使用-hexo-renderer-mathjax-代替-hexo-math"><a href="#二、使用-hexo-renderer-mathjax-代替-hexo-math" class="headerlink" title="二、使用 hexo-renderer-mathjax 代替 hexo-math"></a>二、使用 hexo-renderer-mathjax 代替 hexo-math</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>
<h4 id="三、更新-Mathjax-的-CDN-链接"><a href="#三、更新-Mathjax-的-CDN-链接" class="headerlink" title="三、更新 Mathjax 的 CDN 链接"></a>三、更新 Mathjax 的 CDN 链接</h4><p>找到根目录下的 <strong><code>/node_modules/hexo-renderer-mathjax/mathjax.html</code></strong> 文件，将最后的 script 标签改成如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="四、更改默认转义规则"><a href="#四、更改默认转义规则" class="headerlink" title="四、更改默认转义规则"></a>四、更改默认转义规则</h4><p>找到根目录下的 <strong><code>/node_modules/kramed/lib/rules/inline.js</code></strong> 文件</p>
<p><strong>将第 11 行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p><strong>改成</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p><strong>将第 21 行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">em: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p><strong>改成</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<h4 id="五、开启mathjax"><a href="#五、开启mathjax" class="headerlink" title="五、开启mathjax"></a>五、开启mathjax</h4><p>先打开主题的配置文件，以 next 主题为例，打开<code>\theme\next\_config.yml</code>，搜索mathjax，设置成如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>在文章的 Front-matter 里打开 mathjax 开关</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: hexo中启用 mathjax 的方式</span><br><span class="line">date: 2021-1-4</span><br><span class="line">mathjax: true # 启用 mathjax</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>md 文档中使用 mathjax 语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$F(n)&#x3D;\frac&#123;1&#125;&#123;\sqrt5&#125;\left[\left(\frac&#123;1+\sqrt5&#125;&#123;2&#125;\right)^n-\left(\frac&#123;1-\sqrt5&#125;&#123;2&#125;\right)^n\right]$$</span><br></pre></td></tr></table></figure>
<p><strong>显示效果</strong></p>
<script type="math/tex; mode=display">F(n)=\frac{1}{\sqrt5}\left[\left(\frac{1+\sqrt5}{2}\right)^n-\left(\frac{1-\sqrt5}{2}\right)^n\right]</script><p>至此大功告成！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo爬坑</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.13</title>
    <url>/2021/01/13/lc2021.1.13/</url>
    <content><![CDATA[<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复<code>1, 2, ..., N</code>) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对 <code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和 <code>v</code>的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着<code>N</code>个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>输入的二维数组大小在 3 到 1000。</li>
<li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</span><br><span class="line"></span><br><span class="line">树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。</span><br><span class="line"></span><br><span class="line">可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</span><br><span class="line"></span><br><span class="line">    • 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</span><br><span class="line"></span><br><span class="line">    • 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(NlogN)，其中 N 是图中的节点个数。</li>
<li>空间复杂度：O(N)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findRedundantConnection = <span class="function"><span class="keyword">function</span> (<span class="params">edges</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodesCount = edges.length;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="built_in">Array</span>(nodesCount + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [node1, node2] = edges[i];</span><br><span class="line">        <span class="keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class="line">            union(parent, node1, node2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">parent, index1, index2</span>) =&gt;</span> &#123;</span><br><span class="line">    parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">parent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[index] !== index) &#123;</span><br><span class="line">        parent[index] = find(parent, parent[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 使用 npm 显示无权限</title>
    <url>/2021/12/02/2021.12.02/</url>
    <content><![CDATA[<h2 id="Mac-使用-npm-安装包的时候显示权限错误"><a href="#Mac-使用-npm-安装包的时候显示权限错误" class="headerlink" title="Mac 使用 npm 安装包的时候显示权限错误"></a>Mac 使用 npm 安装包的时候显示权限错误</h2><a id="more"></a>
<blockquote>
<p>报错截图</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="images/2021-12-02.png" alt="no permission"></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>npm 包管理器下载各种包的时候依赖 <strong>nodejs</strong>， 而你的 nodejs 是在官网上安装的 <code>.pkg</code> 包，这种方式是通过安装器来实现的，导致 npm 在安装全局包的时候出现权限错误。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>这里我们直接来看 npm 官方推荐的方式：</p>
<ul>
<li>通过 node 版本工具重新安装你的 npm</li>
</ul>
<h4 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h4><blockquote>
<p>由于网络问题，通过 nvm 官网提供的安装脚本很有可能安装失败，推荐手动安装 nvm。</p>
</blockquote>
<ol>
<li><p>终端中输入一下命令安装 nvm</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span> &amp;&amp; (</span><br><span class="line">  git <span class="built_in">clone</span> https://github.com/nvm-sh/nvm.git <span class="string">"<span class="variable">$NVM_DIR</span>"</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="string">"<span class="variable">$NVM_DIR</span>"</span></span><br><span class="line">  git checkout `git describe --abbrev=0 --tags --match <span class="string">"v[0-9]*"</span> $(git rev-list --tags --max-count=1)`</span><br><span class="line">) &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>~/.zshrc</code> 中 添加如下代码：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure>
<p> 如果本地没有 <code>.zshrc</code> 文件，就先创建一个</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch .zshrc</span><br></pre></td></tr></table></figure>
<p> 最后终端查看一下 nvm 的版本，安装成功</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm -v</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用-nvm-安装-nodejs"><a href="#使用-nvm-安装-nodejs" class="headerlink" title="使用 nvm 安装 nodejs"></a>使用 nvm 安装 nodejs</h4><blockquote>
<p>这里装的是 16.x 的版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install 16 // 推荐用这个</span><br><span class="line"></span><br><span class="line">nvm install node // 下载的是最新版本的 node，不建议用最新的</span><br></pre></td></tr></table></figure>
<p>装完可以查看一下 node 和 npm 的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm --version</span><br><span class="line"></span><br><span class="line">node --version</span><br></pre></td></tr></table></figure>
<h3 id="刨根究底"><a href="#刨根究底" class="headerlink" title="刨根究底"></a>刨根究底</h3><p>为什么通过 nvm 安装之后就不会出现权限的问题呢？</p>
<p>因为 nvm 安装的 Node.js 路径并不在需要权限的路径中</p>
<p>终端中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open .nvm</span><br></pre></td></tr></table></figure>
<p>此时终端将会打开 Finder。我们就可以发现 Node.js 其实是安装在用户根目录（也就是~这个路径 ）上的。</p>
<p><img data-src="/images/loading.gif" data-original="images/nvm_path.png" alt="nvm path"></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.10</title>
    <url>/2021/01/10/lc2021.1.10/</url>
    <content><![CDATA[<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">228. 汇总区间</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p>
<p>返回 <code>恰好覆盖数组中所有数字</code> 的 <code>最小有序</code> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p>
<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li>
<li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 ≤ nums.length ≤ 20</code></li>
<li>-2<sup>31</sup> ≤ nums[i] ≤ 2<sup>31</sup>-1</li>
<li><code>nums 中的所有值都 互不相同</code></li>
<li><code>nums 按升序排列</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">一次遍历即可，遍历 nums[i]，判断 nums[i+1] 是不是比 nums[i] 大 1:</span><br><span class="line"></span><br><span class="line">    如果是说明形成一个区间，继续往后找，知道找一个数 nums[j] 不满足条件，这个时候 [i, j] 区间内的数就是一个区间，区间就是 nums[i] -&gt; nums[j]]</span><br><span class="line"></span><br><span class="line">    如果不是就说明这个数就是一个区间 nums[i]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($n$)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(1)，除了用于输出的空间外，额外使用的空间为常数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> summaryRanges = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] + <span class="number">1</span> === nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] + <span class="number">1</span> === nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push([nums[i], nums[j]].join(<span class="string">'-&gt;'</span>))</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.push(<span class="string">''</span> + nums[i])</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.14</title>
    <url>/2021/01/14/lc2021.1.14/</url>
    <content><![CDATA[<h2 id="1018-可被-5-整除的二进制前缀"><a href="#1018-可被-5-整除的二进制前缀" class="headerlink" title="1018. 可被 5 整除的二进制前缀"></a><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/" target="_blank" rel="noopener">1018. 可被 5 整除的二进制前缀</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>。我们定义 <code>N_i</code>：从 <code>A[0]</code> 到 <code>A[i]</code> 的第 <code>i</code> 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p>
<p>返回布尔值列表 <code>answer</code>，只有当 <code>N_i</code> 可以被 <code>5</code> 整除时，答案 <code>answer[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,1]</span><br><span class="line">输出：[true,false,false]</span><br><span class="line">解释：</span><br><span class="line">输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：[false,false,false]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,1,1,1,1]</span><br><span class="line">输出：[true,false,false,false,true,false]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,0,1]</span><br><span class="line">输出：[false,false,false,false,false]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 ≤ A.length ≤ 30000</code></li>
<li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li>
</ol>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">对数组 [A[0], A[1], A[2]] 模拟一下这个过程： </span><br><span class="line"></span><br><span class="line">    第一个数N1：A[0]，然后对 5 去余判断是否为0</span><br><span class="line">    第二个数N2：A[0] * 2 + A[1]，然后对 5 去余判断是否为0</span><br><span class="line">    第三个数N3：A[0] * 4 + A[1] * 2 + A[2]，然后对 5 去余判断是否为0</span><br><span class="line"></span><br><span class="line">我们可以发现 N(i) &#x3D; N(i-1) * 2 + A[i-1]</span><br><span class="line"></span><br><span class="line">考虑到数组 A 可能很长，如果每次都保留 N(i) 的值，则可能导致溢出。</span><br><span class="line"></span><br><span class="line">但是因为只需要知道 N(i) 是否可以被 5 整除，因而我们可以每一轮只更新 N(i) % 5，结果不会影响，即</span><br><span class="line"></span><br><span class="line">N(i) &#x3D; (N(i-1) * 2 + A[i-1]) % 5</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($n$)，其中 n 是数组 A 的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prefixesDivBy5 = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">let</span> len = A.length;</span><br><span class="line">    <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        prefix = (prefix * <span class="number">2</span> + A[i]) % <span class="number">5</span>;</span><br><span class="line">        ret.push(prefix === <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.2</title>
    <url>/2021/01/02/lc2021.1.2/</url>
    <content><![CDATA[<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<a id="more"></a>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong> 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong> 5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：</p>
<ul>
<li><code>1 ≤ nums.length ≤ 105</code></li>
<li><code>-104 ≤ nums[i] ≤ 104</code></li>
<li><code>1 ≤ k ≤ nums.length</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：-暴力法"><a href="#方法1：-暴力法" class="headerlink" title="方法1： 暴力法"></a>方法1： 暴力法</h4><ul>
<li>时间复杂度：O((n-k-1) * k)，n 是 nums 的长度。总共 n-k-1 个滑动窗口，每个滑动窗口的找最大值的复杂度为 O(k)，这种方式超出了题的时间限制。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= nums.length - k; i++) &#123;</span><br><span class="line">        res.push(<span class="built_in">Math</span>.max(...nums.slice(i, i + k)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：滑动窗口-双端队列"><a href="#方法2：滑动窗口-双端队列" class="headerlink" title="方法2：滑动窗口 + 双端队列"></a>方法2：滑动窗口 + 双端队列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">双端队列：</span><br><span class="line">    每次push元素时，将队列中更小元素删除，直到不小时</span><br><span class="line">    每次pop元素时，如果是更小的元素在push时就已经删除了，只需要判断是否是头部最大值，是再删除一遍头部元素即可</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">slideWindow</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">this</span>.deque = [];</span><br><span class="line">        &#125;</span><br><span class="line">        push(val) &#123; <span class="comment">// 队列从尾部开始，把小于val的数都去掉，然后将val加入队列末尾</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.deque.length &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.deque[<span class="keyword">this</span>.deque.length - <span class="number">1</span>] &lt; val) &#123;</span><br><span class="line">                <span class="keyword">this</span>.deque.pop()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.deque.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">        pop(val) &#123; <span class="comment">// 判断以下队首元素是不是val（最大值）,是就删除，不是就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deque.length &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.deque[<span class="number">0</span>] === val) &#123;</span><br><span class="line">                <span class="keyword">this</span>.deque.shift()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deque[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">window</span> = <span class="keyword">new</span> slideWindow();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">window</span>.push(nums[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.push(nums[i]);</span><br><span class="line">            res.push(<span class="built_in">window</span>.max())</span><br><span class="line">            <span class="built_in">window</span>.pop(nums[i - k + <span class="number">1</span>]) <span class="comment">// 判断滑动窗口的左边元素是不是window的左边元素，是的话就弹掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.20</title>
    <url>/2021/01/20/lc2021.1.20/</url>
    <content><![CDATA[<h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定的整型数组长度范围是 <code>[3,104]</code>，数组中所有的元素范围是 <code>[-1000, 1000]</code>。</li>
<li>输入的数组中任意三个数的乘积不会超出 <code>32</code> 位有符号整数的范围。</li>
</ol>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">先把数组按从小到大排个序,发现无非两种情况:</span><br><span class="line"></span><br><span class="line">1. 数组是纯负数,类似 [-4, -3, -2, -1]</span><br><span class="line">    最大乘积就应该是最大的几个数的乘积</span><br><span class="line"></span><br><span class="line">2. 数组不是纯负数,</span><br><span class="line">    (1)可能是纯正数,最大的乘积就是最大的几个数的乘积,类似于 [1, 2, 3, 4]</span><br><span class="line">    (2)可能是有正有负,那就判断一下最小的两个负数的乘积是不是要比次大的两个正数的乘积大,类似于[-5, -4, 1, 2, 3]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度:O(nlogn)</li>
<li>空间复杂度:O(logn)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumProduct = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n - <span class="number">1</span>], nums[n - <span class="number">1</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">3</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.22</title>
    <url>/2021/01/22/lc2021.1.22/</url>
    <content><![CDATA[<h2 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>对于非负整数 <code>X</code> 而言，<code>X</code> 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为 <code>[1,2,3,1]</code>。</p>
<p>给定非负整数 <code>X</code> 的数组形式 <code>A</code>，返回整数 <code>X+K</code> 的数组形式。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,0,0], K &#x3D; 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 &#x3D; 1234</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 &#x3D; 455</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [2,1,5], K &#x3D; 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 &#x3D; 1021</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [9,9,9,9,9,9,9,9,9,9], K &#x3D; 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 &#x3D; 10000000000</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 ≤ A.length ≤ 10000</code></li>
<li><code>0 ≤ A[i] ≤ 9</code></li>
<li><code>0 ≤ K ≤ 10000</code></li>
<li><code>如果 A.length &gt; 1，那么 A[0] ≠ 0</code></li>
</ol>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="倒序逐位相加"><a href="#倒序逐位相加" class="headerlink" title="倒序逐位相加"></a>倒序逐位相加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"></span><br><span class="line">对数组 A 倒序遍历，每轮遍历的时候加上 K 对 10 取的余数，将和判断是否大于 10 后加入 ret 数组中，并对 K 进行更新。</span><br><span class="line"></span><br><span class="line">遍历完再对 K 做一个遍历直到 K &#x3D; 0 为止。</span><br><span class="line"></span><br><span class="line">例如：A &#x3D; [1, 2, 3]  K &#x3D; 912</span><br><span class="line">第一轮遍历： 3 + 2 &#x3D; 5，此时 K &#x3D; 91，ret &#x3D; [5]</span><br><span class="line">第二轮遍历： 2 + 1 &#x3D; 3，此时 K &#x3D; 9， ret &#x3D; [3, 5]</span><br><span class="line">第三轮遍历： 9 + 1 &#x3D; 10，此时 K &#x3D; 0 + 1 &#x3D; 1， ret &#x3D; [0, 3, 5]</span><br><span class="line">K &#x3D; 1，还要再向 ret 中加入 1，ret &#x3D; [1, 0, 3, 5]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($max{m,n}$)，其中 m 是数组 A 的长度，n 是数字 K 的长度</li>
<li>空间复杂度：O($max{m,n}$)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addToArrayForm = <span class="function"><span class="keyword">function</span> (<span class="params">A, K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = A[i] + K % <span class="number">10</span>;</span><br><span class="line">        K = <span class="built_in">Math</span>.floor(K / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            ret.unshift(sum % <span class="number">10</span>);</span><br><span class="line">            K++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.unshift(sum)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K = <span class="built_in">Math</span>.floor(K / <span class="number">10</span>)) &#123;</span><br><span class="line">        ret.unshift(K % <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.24</title>
    <url>/2021/01/24/lc2021.1.24/</url>
    <content><![CDATA[<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r（l &lt; r）</code>确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>0 ≤ nums.length ≤ $10^4$</li>
<li>-$10^9$ ≤ nums[i] ≤ $10^9$</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp矩阵的定义</span><br><span class="line">    dp[i] 定义为以 nums[i] 结尾的连续递增子序列的最大长度</span><br><span class="line"></span><br><span class="line">转移方程很好理解，dp[i-1] --&gt; dp[i]</span><br><span class="line">    如果 nums[i] &gt; nums[i-1]，那么 dp[i] &#x3D; dp[i-1] + 1，也就是与前面的组成连续递增子序列</span><br><span class="line">    否则的话，nums[i] 自成一组连续递增子序列，即 dp[i] &#x3D; 1</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：贪心"><a href="#方法2：贪心" class="headerlink" title="方法2：贪心"></a>方法2：贪心</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用一个 start 指针记录连续递增子序列的头部位置，初始时 start &#x3D; 0，然后遍历数组进行如下操作：</span><br><span class="line"></span><br><span class="line">    1. 如果下标 nums[i] ≤ nums[i−1]，则说明当前元素小于或等于上一个元素，因此 nums[i−1] 和 nums[i] 不可能属于同一个连续递增序列，</span><br><span class="line">    必须从下标 i 处开始一个新的连续递增序列，因此令 start&#x3D;i。如果下标 i&#x3D;0 或 nums[i] &gt; nums[i−1]，则不更新 start 的值。</span><br><span class="line"></span><br><span class="line">    2.此时下标范围 [start,i] 的连续子序列是递增序列，其长度为 i−start+1，使用当前连续递增序列的长度更新最长连续递增序列的长度。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">Math</span>.max(ret, i - start + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.28</title>
    <url>/2021/01/28/lc2021.1.28/</url>
    <content><![CDATA[<h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组 “<strong>中心索引</strong>” 的方法。</p>
<p>我们是这样定义数组 <strong>中心索引</strong> 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。<br><a id="more"></a></p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">索引 3 (nums[3] &#x3D; 6) 的左侧数之和 (1 + 7 + 3 &#x3D; 11)，与右侧数之和 (5 + 6 &#x3D; 11) 相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>nums 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code> 的整数。</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算所有数字的和为 total，记录左侧元素的和 sum，每次判断 2 * sum 加上当前元素是不是等于 total</span><br><span class="line"></span><br><span class="line">    是就直接返回当前索引</span><br><span class="line">    </span><br><span class="line">    否则遍历结束都没有就返回 -1</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，n 为数组 nums 的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = nums.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] === total) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.26</title>
    <url>/2021/01/26/lc2021.1.26/</url>
    <content><![CDATA[<h2 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/" target="_blank" rel="noopener">1128. 等价多米诺骨牌对的数量</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p>
<p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>
<p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a=c</code> 且 <code>b=d</code>，或是 <code>a=d</code> 且 <code>b=c</code>。</p>
<p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：dominoes &#x3D; [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 ≤ dominoes.length ≤ 40000</li>
<li>1 ≤ dominoes[i][j] ≤ 9</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：排序-哈希map-计数"><a href="#方法1：排序-哈希map-计数" class="headerlink" title="方法1：排序 + 哈希map + 计数"></a>方法1：排序 + 哈希map + 计数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将 dominoes 数组中每一项按从小到大排个序变为字符串，然后哈希表记录下出每个字符串出现的次数，最后遍历哈希表即可得</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，n 是数组的长度。</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numEquivDominoPairs = <span class="function"><span class="keyword">function</span>(<span class="params">dominoes</span>) </span>&#123;</span><br><span class="line">    dominoes = dominoes.map(<span class="function"><span class="params">e</span> =&gt;</span> e[<span class="number">0</span>] &lt; e[<span class="number">1</span>] ? <span class="string">''</span> + e[<span class="number">0</span>] + e[<span class="number">1</span>] : <span class="string">''</span> + e[<span class="number">1</span>] + e[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> dominoe <span class="keyword">of</span> dominoes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(dominoe)) &#123;</span><br><span class="line">            map.set(dominoe, map.get(dominoe) + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(dominoe, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    map.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        ret += value * (value - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：二元组表示-计数"><a href="#方法2：二元组表示-计数" class="headerlink" title="方法2：二元组表示 + 计数"></a>方法2：二元组表示 + 计数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先我们直接让每一个二元对都变为指定的格式，即第一维必须不大于第二维。这样两个二元对「等价」当且仅当两个二元对完全相同。</span><br><span class="line"></span><br><span class="line">其次注意到二元对中的元素均不大于 9，因此我们可以将每一个二元对拼接成一个两位的正整数，即 (x,y) -&gt; 10x+y。</span><br><span class="line">这样就无需使用哈希表统计元素数量，而直接使用长度为 100 的数组即可。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，n 是数组的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numEquivDominoPairs = <span class="function"><span class="keyword">function</span> (<span class="params">dominoes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ele <span class="keyword">of</span> dominoes) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = ele[<span class="number">0</span>] &gt; ele[<span class="number">1</span>] ? <span class="number">10</span> * ele[<span class="number">1</span>] + ele[<span class="number">0</span>] : <span class="number">10</span> * ele[<span class="number">0</span>] + ele[<span class="number">1</span>];</span><br><span class="line">        arr[val]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        ret += n * (n - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.3</title>
    <url>/2021/01/03/lc2021.1.3/</url>
    <content><![CDATA[<h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">模拟两个链表，small 表示比 x 小的，large 一个表示比 x 大的，</span><br><span class="line">然后遍历原链表，将值比 x 小的接到 small 后面，否则接到 large 后面，</span><br><span class="line">最后再把 small 链表的尾部和 large 链表的头部连起来。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，n 是原链表的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">head, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> small = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> large = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> smallHead = small, largeHead = large;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">            small.next = head;</span><br><span class="line">            small = small.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.next = head;</span><br><span class="line">            large = large.next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    large.next = <span class="literal">null</span></span><br><span class="line">    small.next = largeHead.next</span><br><span class="line">    <span class="keyword">return</span> smallHead.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.4</title>
    <url>/2021/01/04/lc2021.1.4/</url>
    <content><![CDATA[<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p><strong>斐波那契数</strong>，通常用 F(n) 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 ≤ n ≤ 30</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1：通项公式"><a href="#方法1：通项公式" class="headerlink" title="方法1：通项公式"></a>方法1：通项公式</h4><p>斐波那契数 F(n) 是齐次线性递推，根据递推方程 F(n)=F(n-1)+F(n-2)，可以写出这样的特征方程：</p>
<script type="math/tex; mode=display">x ^ 2=x+1</script><p>求得$x_1=\frac{1+\sqrt5}{2}$，$x_2=\frac{1-\sqrt5}{2}$。设通解为$F(n)=c_1x_1^n+c_2x_2^n$，代入初始条件$F(n)=0, F(1)=1$，得$c_1=\frac{1}{\sqrt5}，c_2=-\frac{1}{\sqrt5}$。因此斐波那契数得通项公式如下：</p>
<script type="math/tex; mode=display">
    F(n)=\frac{1}{\sqrt5}
    \left[
        \left(
            \frac{1+\sqrt5}{2}
        \right)^n-
        \left(\frac{1-\sqrt5}{2}
        \right)^n
    \right]</script><p>得到通项公式之后，就可以通过公式直接求解第 n 项。</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> fibN = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(fibN / sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：循环法"><a href="#方法2：循环法" class="headerlink" title="方法2：循环法"></a>方法2：循环法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斐波那契数的特点就是当前的数等于前两个树之和，那我们可以用三个变量 a b res 分别表示第一个数、第二个数、第三个数</span><br><span class="line"></span><br><span class="line">然后在循环的时候不断更新即可</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">-1</span>, b = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        res = a+b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法3：动态规划"><a href="#方法3：动态规划" class="headerlink" title="方法3：动态规划"></a>方法3：动态规划</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp 矩阵的定义：</span><br><span class="line">    dp[i] 定义为第 i 个数</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line">    dp[i] &#x3D; dp[i-1] + dp[i-2]</span><br><span class="line"></span><br><span class="line">目标：</span><br><span class="line">    dp[n]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法4：递归法"><a href="#方法4：递归法" class="headerlink" title="方法4：递归法"></a>方法4：递归法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们要求 fib(n) ，那就是要求 fib(n-1) 和 fib(n-2)，依次下去...</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($2^n$)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n===<span class="number">0</span> || n===<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.5</title>
    <url>/2021/01/05/lc2021.1.5/</url>
    <content><![CDATA[<h2 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p>
<p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p>
<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p>
<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>
<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">我们可以遍历该序列，并记录当前分组的长度。如果下一个字符与当前字符不同，或者已经枚举到字符串尾部，就说明当前字符为当前分组的尾部。</span><br><span class="line"></span><br><span class="line">每次找到当前分组的尾部时，如果该分组长度达到 3，我们就将其加入答案。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，n 是 s 的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largeGroupPositions = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === n<span class="number">-1</span> || s[i+<span class="number">1</span>] !== s[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                res.push([i - num + <span class="number">1</span>, i])</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.6</title>
    <url>/2021/01/06/lc2021.1.6/</url>
    <content><![CDATA[<h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p>
<p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p>
<p><strong>注意：</strong><br>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">问题：a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：equations &#x3D; [[&quot;a&quot;,&quot;b&quot;]], values &#x3D; [0.5], queries &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">输出：[0.50000,2.00000,-1.00000,-1.00000]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 ≤ equations.length ≤ 20</code></li>
<li><code>equations[i].length = 2</code></li>
<li><code>1 ≤ Ai.length, Bi.length ≤ 5</code></li>
<li><code>values.length = equations.length</code></li>
<li><code>0.0 &lt; values[i] ≤ 20.0</code></li>
<li><code>1 ≤ queries.length ≤ 20</code></li>
<li><code>queries[i].length = 2</code></li>
<li><code>1 ≤ Cj.length, Dj.length ≤ 5</code></li>
<li><code>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">我们将这种关系表示为存储为邻接表</span><br><span class="line"></span><br><span class="line">如下图这种关系我们将其保存为如下邻接表格式：</span><br><span class="line"></span><br><span class="line">map &#x3D; &#123;</span><br><span class="line">    a: &#123; b: 2 &#125;,</span><br><span class="line">    b: &#123; a: 1&#x2F;2, c: 3 &#125;,</span><br><span class="line">    c: &#123; b: 1&#x2F;3 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后我们再扩展出所有可能的情况，例如 a&#x2F;b 和 b&#x2F;c 可以扩展到 a&#x2F;c</span><br><span class="line"></span><br><span class="line">最后只要对 queries 数组遍历得到结果即可</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="/images/leetcode2021.1.6.png" alt="关系图"></p>
<ul>
<li>时间复杂度：O($n^3$)，n 是所有可能的字符的个数。</li>
<li>空间复杂度：O($n$)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calcEquation = <span class="function"><span class="keyword">function</span> (<span class="params">equations, values, queries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义一个对象，map[x][y] 表示 x/y 的值</span></span><br><span class="line">    equations.forEach(<span class="function">(<span class="params">e, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map[e[<span class="number">0</span>]]) map[e[<span class="number">0</span>]] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!map[e[<span class="number">1</span>]]) map[e[<span class="number">1</span>]] = &#123;&#125;;</span><br><span class="line">        map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = values[i]</span><br><span class="line">        map[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span> / values[i]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(map);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">        keys.forEach(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            map[x][y] &amp;&amp; keys.forEach(<span class="function"><span class="params">z</span> =&gt;</span> &#123; <span class="comment">// 如果 x/y 有值 y/z 也有值，则 x/z 的值也可以求出</span></span><br><span class="line">                <span class="keyword">if</span> (map[y][z]) &#123;</span><br><span class="line">                    map[x][z] = map[x][y] * map[y][z]</span><br><span class="line">                    map[z][x] = <span class="number">1</span> / map[x][z] <span class="comment">// 这行不加会有一个测试案例通过不了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> queries.map(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map[e[<span class="number">0</span>]] &amp;&amp; map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] ? map[e[<span class="number">0</span>]][e[<span class="number">1</span>]] : <span class="number">-1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.7</title>
    <url>/2021/01/07/lc2021.1.7/</url>
    <content><![CDATA[<h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">547. 省份数量</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img data-src="/images/loading.gif" data-original="/images/202101071.jpg" alt="示例1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img data-src="/images/loading.gif" data-original="/images/202101072.jpg" alt="示例1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 ≤ n ≤ 200</code></li>
<li><code>n = isConnected.length</code></li>
<li><code>n = isConnected[i].length</code></li>
<li><code>isConnected[i][j] 为 1 或 0</code></li>
<li><code>isConnected[i][i] = 1</code></li>
<li><code>isConnected[i][j] = isConnected[j][i]</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><p>可以把 n 个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，给定的矩阵 isConnected 即为图的邻接矩阵，省份即为图中的连通分量。</p>
<p>计算省份总数，等价于计算图中的连通分量数，可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。</p>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，</span><br><span class="line"></span><br><span class="line">通过矩阵 isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，</span><br><span class="line"></span><br><span class="line">直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($n^2$)，n 是城市的个数。</li>
<li>空间复杂度：O($n$)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span> (<span class="params">isConnected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">isConnected, visited, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] === <span class="number">1</span> &amp;&amp; !visited.has(j)) &#123; <span class="comment">// 城市 i 和 j 相连，并且 j 没有并访问过</span></span><br><span class="line">                visited.add(j);</span><br><span class="line">                dfs(isConnected, visited, j) <span class="comment">// 继续遍历和城市j相连的城市，标记已访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(i)) &#123; <span class="comment">// 城市 i 没有被访问过</span></span><br><span class="line">            dfs(isConnected, visited, i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">通过广度优先搜索的方法得到省份的总数。对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，</span><br><span class="line"></span><br><span class="line">直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($n^2$)，n 是城市的个数。</li>
<li>空间复杂度：O($n$)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span> (<span class="params">isConnected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(i)) &#123;</span><br><span class="line">            queue.push(i)</span><br><span class="line">            <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">                <span class="keyword">let</span> j = queue.shift();</span><br><span class="line">                visited.add(j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isConnected[j][k] === <span class="number">1</span> &amp;&amp; !visited.has(k)) &#123;</span><br><span class="line">                        queue.push(k)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.8</title>
    <url>/2021/01/08/lc2021.1.8/</url>
    <content><![CDATA[<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个数组，将数组中的元素向右移动 $k$ 个位置，其中 $k$ 是非负数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法。</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">循环 k 次：将数组最后一个元素弹出，添加到数组头部</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($k*n$)，n 为数组的长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums.unshift(nums.pop())</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题解</span><br><span class="line"></span><br><span class="line">当我们将数组的元素向右移动 k 次后，尾部 k%n 个元素会移动至数组头部，其余元素向后移动 k%n 个位置。</span><br><span class="line"></span><br><span class="line">我们可以先将所有元素翻转，这样尾部的 k%n 个元素就被移至数组头部，然后我们再翻转 [0, k%n-1] 区间的元素和 [k%n, n-1] 区间的元素即能得到最后的答案。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O($n$)，n 是城市的个数。</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function">(<span class="params">nums, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            [nums[start], nums[end]] = [nums[end], nums[start]]</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    k = k % n;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">    reverse(nums, k, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.1.9</title>
    <url>/2021/01/09/lc2021.1.9/</url>
    <content><![CDATA[<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 ≤ prices.length ≤ 105</code></li>
<li><code>0 ≤ prices[i] ≤ 105</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>题解：</p>
<p>在任意一天结束后，我们会处于五种状态中的一种：</p>
<ul>
<li>未进行任何操作</li>
<li>只进行了一次买操作</li>
<li>只进行一次买操作和一次卖操作，即完成了一笔交易</li>
<li>在完成了一笔交易的前提下，进行了第二次买操作</li>
<li>完成了两笔交易</li>
</ul>
<p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 $buy_1$, $sell_1$, $buy_2$, $sell_2$</p>
<p>状态转移，知道第 <code>i-1</code> 天结束后的这四个状态，第 <code>i</code> 天的状态：</p>
<ul>
<li>对于 $buy_1$</li>
</ul>
<p>在第 <code>i</code> 天可以不进行任何操作，保持不变，也可以在未进行任何操作的前提下以 <code>prices[i]</code> 的价格买入股票，转移方程为：</p>
<script type="math/tex; mode=display">buy_1(i) = max\{buy_1(i-1), -prices[i]\}</script><p>其中，$buy_1(i)$ 表示 <code>i</code> 天的状态，$buy_1(i-1)$ 表示 <code>i-1</code> 天的状态，下面也是类似。</p>
<ul>
<li>对于 $sell_1$</li>
</ul>
<p>在第 <code>i</code> 天我们可以不进行任何操作，保持不变，也可以在只进行过一次买操作的前提下以 <code>prices[i]</code> 的价格卖出股票，转移方程为：</p>
<script type="math/tex; mode=display">sell_1(i) = max\{sell_1(i-1), buy_1(i)+prices[i]\}</script><ul>
<li>对于 $buy_2$</li>
</ul>
<p>同理转移方程为：</p>
<script type="math/tex; mode=display">buy_2(i) = max\{buy_2(i-1), sell_1(i)-prices[i]\}</script><ul>
<li>对于 $sell_2$</li>
</ul>
<p>同理转移方程为：</p>
<script type="math/tex; mode=display">sell_2(i) = max\{sell_2(i-1), buy_2(i)+prices[i]\}</script><p>理论上，我们需要维护四个数组  $buy_1[i]$ , $sell_1[i]$ , $buy_2[i]$ , $sell_2[i]$ ，但是因为每个状态只与前一天的状态有关，因而我们可以进一步降低空间复杂度，我们只需维护四个变量：$buy_1$ , $sell_1$ , $buy_2$ , $sell_2$，然后不断的更新这四个变量即可。</p>
<ul>
<li>总的状态转移方程为：</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
    buy_1 = max\{buy_1, -prices[i]\}\\
    sell_1 = max\{sell_1, buy_1+prices[i]\}\\
    buy_2 = max\{buy_2, sell_1-prices[i]\}\\
    sell_2 = max\{sell_2, buy_2+prices[i]\}
\end{cases}</script><ul>
<li>时间复杂度：O($n$)，其中 n 是数组 prices 的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = prices.length;</span><br><span class="line">    <span class="keyword">let</span> buy1 = -prices[<span class="number">0</span>], buy2 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy1 = <span class="built_in">Math</span>.max(buy1, -prices[i])</span><br><span class="line">        sell1 = <span class="built_in">Math</span>.max(sell1, buy1 + prices[i])</span><br><span class="line">        buy2 = <span class="built_in">Math</span>.max(buy2, sell1 - prices[i])</span><br><span class="line">        sell2 = <span class="built_in">Math</span>.max(sell2, buy2 + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.2.1</title>
    <url>/2021/02/01/lc2021.2.1/</url>
    <content><![CDATA[<h2 id="888-公平的糖果棒交换"><a href="#888-公平的糖果棒交换" class="headerlink" title="888. 公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果棒交换</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p>
<p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p>
<p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p>
<p>如果有多个答案，你可以返回其中任何一个。保证答案存在。<br><a id="more"></a></p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2], B &#x3D; [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [2], B &#x3D; [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,5], B &#x3D; [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 ≤ A.length ≤ 10000</code></li>
<li><code>1 ≤ B.length ≤ 10000</code></li>
<li><code>1 ≤ A[i] ≤ 100000</code></li>
<li><code>1 ≤ B[i] ≤ 100000</code></li>
<li>保证爱丽丝与鲍勃的糖果总量不同。</li>
<li>答案肯定存在。</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>思路如下：</p>
<hr>
<p>这是一个纯数学问题，我们来把它数学化：</p>
<p>假设我们最后得结果是 $[a, b]$，也就是 $a$ 是 $A$ 要交换得，$b$ 是 $B$ 要交换的</p>
<p>我们可以计算分别得到 $A$ 和 $B$ 的和为 $aSum$ 和 $bSum$，那我们会有如下关系：</p>
<script type="math/tex; mode=display">aSum - a + b = bSum - b + a</script><p>转化一下可以得到：</p>
<script type="math/tex; mode=display">a = b + \frac{aSum - bSum}{2}</script><p>其实问题就是：对于 $B$ 中的任一数 $b$，在 $A$ 中存在一个数 $a$，满足上述关系式。</p>
<hr>
<ul>
<li>时间复杂度：$O(n+m)$，$n$ 和 $m$ 分别为 $A$ 和 $B$ 的长度。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fairCandySwap = <span class="function"><span class="keyword">function</span> (<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aSum = A.reduce(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> preValue + curValue);</span><br><span class="line">    <span class="keyword">let</span> bSum = B.reduce(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> preValue + curValue);</span><br><span class="line">    <span class="keyword">let</span> diff = (aSum - bSum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = new Set(A);</span><br><span class="line">    let res = [];</span><br><span class="line">    for (const y of B) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = y + diff;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.has(x)) &#123;</span><br><span class="line">            res = [x, y]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.2.22</title>
    <url>/2021/02/22/lc2021.2.22/</url>
    <content><![CDATA[<h2 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img data-src="/images/loading.gif" data-original="/images/2021022201.jpg" alt="示例1图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img data-src="/images/loading.gif" data-original="/images/2021022202.jpg" alt="示例2图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[2,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m = matrix.length</code></li>
<li><code>n = matrix[i].length</code></li>
<li><code>1 ≤ m, n ≤ 20</code></li>
<li><code>0 ≤ matrix[i][j] ≤ 99</code></li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据定义，当且仅当矩阵中每个元素都与其左上角相邻的元素（如果存在）相等时，该矩阵为托普利茨矩阵。</span><br><span class="line"></span><br><span class="line">因此，我们遍历该矩阵，将每一个元素和它左上角的元素相比对即可。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(m * n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isToeplitzMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] !== matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.2.25</title>
    <url>/2021/02/25/lc2021.2.25/</url>
    <content><![CDATA[<h2 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">867. 转置矩阵</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>
<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<p><img data-src="/images/loading.gif" data-original="/images/20210225.png" alt="20210225"></p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$m = matrix.length$</li>
<li>$n = matrix[i].length$</li>
<li>$1 \le m, n \le 1000$</li>
<li>$1 \le m * n \le 10^{5}$</li>
<li>$-10^{9} ≤ matrix[i][j] ≤ 10^{9}$</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">横纵坐标对换位置即可，很简单。</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(m * n)$，其中 $m$ 为矩阵的行数，$n$ 为矩阵的列数。</li>
<li>空间复杂度：$O(1)$。除了返回值以外，额外使用的空间为常数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transpose = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>(col).fill(<span class="number">0</span>).map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">Array</span>(row).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            res[j][i] = matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题2020.2.6</title>
    <url>/2021/02/06/lc2021.2.6/</url>
    <content><![CDATA[<h2 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。<br><a id="more"></a></p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 ≤ cardPoints.length ≤ 10^{5}$</li>
<li>$1 ≤ cardPoints[i] ≤ 10^{4}$</li>
<li>$1 ≤ k ≤ cardPoints.length$</li>
</ul>
<h3 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>思路如下：</p>
<hr>
<p>题目限制我们只能从开头或结尾拿数字，那么最后剩下的数字一定是连续的</p>
<p>这样我们可以换一种思维，我们找到连续数字和最小的这个滑动窗口即可</p>
<p>滑动窗口的长度:</p>
<script type="math/tex; mode=display">windowSize = cardPoints.length - k</script><hr>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 是数组 $cardPoints$ 的长度。</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxScore = <span class="function"><span class="keyword">function</span> (<span class="params">cardPoints, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cardPoints.length;</span><br><span class="line">    <span class="comment">// 所有数字之和</span></span><br><span class="line">    <span class="keyword">let</span> total = cardPoints.reduce(<span class="function">(<span class="params">preVal, curVal</span>) =&gt;</span> preVal + curVal);</span><br><span class="line">    <span class="keyword">let</span> windowSize = n - k;</span><br><span class="line">    <span class="comment">// 算出起始滑动窗口中数字之和</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; windowSize; i++) &#123;</span><br><span class="line">        sum += cardPoints[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护一个变量 min 保存滑动窗口中数字之和的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = windowSize; j &lt; n; j++) &#123;</span><br><span class="line">        sum = sum - cardPoints[j-windowSize] + cardPoints[j];</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total - min</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack安装node-sass出现问题</title>
    <url>/2020/07/06/webpack%E5%AE%89%E8%A3%85node-sass%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="webpack安装node-sass出现问题"><a href="#webpack安装node-sass出现问题" class="headerlink" title="webpack安装node-sass出现问题"></a>webpack安装node-sass出现问题</h2><p>我的问题反馈是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Downloading binary <span class="keyword">from</span> https:<span class="comment">//github.com/sass/node-sass/releases/download/v4.14.1/win32-x64-72_binding.node</span></span><br><span class="line">Cannot download <span class="string">"https://github.com/sass/node-sass/releases/download/v4.14.1/win32-x64-72_binding.node"</span>:</span><br><span class="line"></span><br><span class="line">ESOCKETTIMEDOUT</span><br><span class="line"></span><br><span class="line">Hint: If github.com is not accessible <span class="keyword">in</span> your location</span><br><span class="line">      <span class="keyword">try</span> setting a proxy via HTTP_PROXY, e.g.</span><br><span class="line"></span><br><span class="line">      <span class="keyword">export</span> HTTP_PROXY=http:<span class="comment">//example.com:1234</span></span><br><span class="line"></span><br><span class="line">or configure npm proxy via</span><br><span class="line"></span><br><span class="line">      npm config <span class="keyword">set</span> proxy http://example.com:8080</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>原因是由于网络限制导致无法下载 .node 文件，解决方法如下：</p>
<p>使用淘宝镜像，使用镜像前请把node_modules文件夹下原有的node-sass有关的文件全删了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry = http:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line">cnpm install node-sass</span><br></pre></td></tr></table></figure>
<h2 id="上述第2步运行可能会碰到如下问题"><a href="#上述第2步运行可能会碰到如下问题" class="headerlink" title="上述第2步运行可能会碰到如下问题"></a>上述第2步运行可能会碰到如下问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm : 无法加载文件 D:\Softwares\nodejs\node_global\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:<span class="regexp">/go.microsoft.com/</span>fwlink/?LinkID=<span class="number">135170</span> 中的 about_Execution_Po</span><br><span class="line">licies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ cnpm install node-sass</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure>
<p>这是说是没有权限，需要用管理员身份进行运行并授权<br>解决方法：</p>
<p>打开本地的 Windows PowerShell，以管理员身份运行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>-ExecutionPolicy RemoteSigned</span><br><span class="line"></span><br><span class="line">再输入 Y 即可</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包之后index.html缺少引号的问题</title>
    <url>/2020/07/06/webpack%E6%89%93%E5%8C%85%E7%BC%BA%E5%B0%91%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="webpack打包之后index-html缺少引号的问题"><a href="#webpack打包之后index-html缺少引号的问题" class="headerlink" title="webpack打包之后index.html缺少引号的问题"></a>webpack打包之后index.html缺少引号的问题</h2><p>下面是通过webpack <code>npm run build</code>打包之后生成的index.html文件，可以看到缺少引号</p>
<p><img data-src="/images/loading.gif" data-original="/images/出错.png" alt="报错问题"></p>
<a id="more"></a>
<h2 id="这里给出解决方案，亲测有效"><a href="#这里给出解决方案，亲测有效" class="headerlink" title="这里给出解决方案，亲测有效"></a>这里给出解决方案，亲测有效</h2><ol>
<li><p>找到<code>webpack.prod.conf.js</code>，在<code>webpack.prod.conf.js</code>找到minify（可以ctrl+F搜索minify），直接将整块(也就是以下这块儿)删除</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">minify: &#123;</span><br><span class="line">    removeComments: <span class="literal">true</span>,</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// more options:</span></span><br><span class="line">    <span class="comment">// https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新打包<code>npm run build</code> 即解决问题，重新打包的index.html文件如下</p>
<p> <img data-src="/images/loading.gif" data-original="/images/解决方法.png" alt="效果图"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器console控制台不显示编译错误/警告</title>
    <url>/2020/07/06/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<h2 id="浏览器console控制台误关了编译错误-警告（不显示了）"><a href="#浏览器console控制台误关了编译错误-警告（不显示了）" class="headerlink" title="浏览器console控制台误关了编译错误/警告（不显示了）"></a>浏览器console控制台误关了编译错误/警告（不显示了）</h2><a id="more"></a>
<p>浏览器正常显示报错应该是这样的<br><img data-src="/images/loading.gif" data-original="/images/控制台报错.jpeg" alt="控制台报错"></p>
<p>但是我一不小心右键给Hide message from…了，红色报错字体就没了，解决方法如下：</p>
<p><img data-src="/images/loading.gif" data-original="/images/控制台报错解决方法.jpeg" alt="控制台报错解决方法"></p>
<p>直接将红色框内的内容叉掉，恢复成filter就OK了</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
